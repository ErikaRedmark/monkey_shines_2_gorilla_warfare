typedef struct {	// gworld and pixmap for screen and menu bar	GWorldPtr		screenGWorld, menuGWorld;	PixMapHandle	screenPixMap, menuPixMap;	Byte			*screenMemPtr;	long			screenRowOffSet;	// gworlds used in game - should be allocated during loading of world, and disposed afterwards	GWorldPtr		darwinGWorld;	PixMapHandle	darwinPixMap;	Byte			*darwinMemPtr;	long			darwinRowOffSet;	// gworld for safe drawing	GWorldPtr		safeGWorld;	PixMapHandle	safePixMap;	Byte			*safeMemPtr;	long			safeRowOffSet;	GWorldPtr		monsterGWorld[50], doorGWorld[8];	PixMapHandle	monsterPixMap[50], doorPixMap[8];	Byte			*monsterMemPtr[50], *doorMemPtr[8];	GWorldPtr		platformGWorld, hazardGWorld, talismanGWorld, itemGWorld, parallaxGWorld, parallaxBackGWorld;	PixMapHandle	platformPixMap, hazardPixMap, talismanPixMap, itemPixMap, parallaxPixMap, parallaxBackPixMap;	GWorldPtr		saveMessageGWorld;	PixMapHandle	saveMessagePixMap;#ifdef DEMO	GWorldPtr		saveMessageTwoGWorld;	PixMapHandle	saveMessageTwoPixMap;#endif	Byte			*platformMemPtr, *hazardMemPtr, *talismanMemPtr, *itemMemPtr, *parallaxMemPtr, *parallaxBackMemPtr;	long			platformRowOffSet, hazardRowOffSet, talismanRowOffSet, itemRowOffSet, parallaxRowOffSet, parallaxBackRowOffSet;		Byte			*conveyorMemPtr, *dissolverMemPtr, *bananaMemPtr, *springMemPtr;} GameGWorlds;typedef struct {	GDHandle		gameGDevice;	RgnHandle		savedGrayRgn, newGrayRgn, coveredRgn;	short			menuBarHeight;	Rect			menuBarRect;	Boolean			gMenuBarHidden, controlStripUsed, controlStripAvailable;	WindowPtr		theWindow, blankingWindow;	CWindowRecord	myCWindowRecord, blankingWindowRecord;	MenuHandle		soundMenu, musicMenu;	ControlHandle	newGameButton, highScoresButton, quitButton, helpButton, controlsButton, 					soundButton, musicButton, soundSliderBar;		#ifdef	DEMO	ControlHandle	registerInfoButton;	#else	ControlHandle	enterCodeButton;	#endif	CCrsrHandle		myCursor;	RgnHandle		cursorRgn;	Boolean			gQuit, gInBackGround, gDialogInBox, cursorHidden;} UserInterfaceStuff;typedef	struct	{	short	applicationFile, worldFile, GWDataFileNumber;#ifndef DEMO	short	saveResFile;	FSSpec	saveFileSpec;	Boolean	saveFileInUse;#endif	FSSpec	worldFileSpec;	long	GWParentDirID;	short	GWvolRef;}	FileStuff;typedef	struct	{	short				musicType;#ifndef DEMO	Boolean				fileOpen;	short				fileRefNum;	Boolean				restartMusic;#endif	short				musicPlaying;	MADDriverRec		*GWMusicDriver;	MADMusic			*GWMusic;	Boolean				madLibraryLoaded;	short				sampleSizeNew, channel;	long				systemSoundVolume;	SndChannelPtr		soundchannel[16];	SndChannelPtr		beanieChannel;	SndChannelPtr		jetPackChannel;	SndChannelPtr		damageChannel;	SndChannelPtr		musicChannel;	Handle				theSounds[79];		// 54 basic sounds plus another 25 for sprite scripts}	AudioStuff;typedef struct {	long	gScore;	short	gLivesLeft;	short	theRoom;	short	worldsCompleted;#ifndef DEMO	short	difficulty;#endif	} GameGlobals;typedef struct {	short	width;	short	height;	short	frames;	} DoorDef, *DoorDefPtr, **DoorDefHandle;#ifndef DEMOtypedef	struct	{	short	worldType;	short	uniqueMonsterNumber;	short	protectedMonsterNumber;	short	testingLevel;	} WorldInfo, **WorldInfoHandle;#endiftypedef struct {	short	spriteType;		// spriteTypeScenery, spriteTypeDrainer, spriteTypeKiller	short	spriteMovement;	// type of movement	short	spriteLayer;	short	aggression;	short	speed;	short	frames;	short	hitPoints;	short	animationSpeed;	short	bananaAction;	// advanced sprite stuff	short	specialFrame;	short	SCRTID;	// which SCRT ID to use for that frame		short	collisionSCRT;	short	horizontalSCRT;	short	verticalSCRT;	short	width;	short	height;		short	closeSCRT;	short	tolerance;		} MonsterDef, *MonsterDefPtr, **MonsterDefHandle;typedef struct {	short	subKind;	Rect	theRect;	short	initiallyFacing;	short	room;		// things which override the basic definition		short	aggression;	short	speed;	short	hitPoints;		} SpriteResource, *SpriteResourcePtr, **SpriteResourceHandle;typedef struct {	short	subKind; // appearance of door	Rect	theRect;	short	room;	Boolean	darwin;	// 0 = left, 1 = right	short	doorNumber;	short	doorDestination;	short	stayOpen;	} DoorResource, *DoorResourcePtr, **DoorResourceHandle;typedef struct {	short	width;	short	height;	short	parallaxH;	short	parallaxV;	short	windowWidthTiles;	short	windowHeightTiles;	short	horizScrollBarPosition, vertScrollBarPosition;	short	backgroundPICT, parallaxPICT;	} Room, *RoomPtr, **RoomHandle;typedef struct DoorSprite {	short	kind;			// what type of sprite ?	short	subKind;	short	room;	Rect	theRect;	short	frame, frames;	short	frameDirection;	short	hArray, vArray;	Boolean	darwinDoor;	short	doorNumber, doorDestination;	short	stayOpen;	short	drawingHeight, drawingWidth;	Boolean	needToDraw;			// does the sprite need drawing ?	short	*source;			// addresses of gworlds	long	sourceRowBytes;	short	*dest;	struct DoorSprite	*nextSprite, *prevSprite;	} DoorSprite, *DoorSpritePtr;typedef struct DoorSpriteSave {	short	kind;			// what type of sprite ?	short	subKind;	short	room;	Rect	theRect;	short	frame, frames;	short	frameDirection;	short	hArray, vArray;	Boolean	darwinDoor;	short	doorNumber, doorDestination;	short	stayOpen;	short	drawingHeight, drawingWidth;	Boolean	needToDraw;			// does the sprite need drawing ?	short	*source;			// addresses of gworlds	long	sourceRowBytes;	short	*dest;	} DoorSpriteSave, *DoorSpriteSavePtr;typedef struct PlayerSprite {	Rect	theRect;	Boolean	directionFacing;	// 1 = left/up, 0 = right/down	Boolean	needToDraw;			// does the sprite need drawing ?	short	*source;			// addresses of gworlds	long	sourceRowBytes;	short	*unused3;	// some attributes of movement and animation	short	iconRow;	short	frame;	float	speedh, speedv;	float	posh;				// for accurate control		DoorSpritePtr	door;	// the door	Boolean	movingVertically;	// just use speed.v ?	Boolean	gJumpingFrames;		// check iconRow ?	Boolean	darwinTired;		// just check stamina ?	Boolean	gLanding;			// needed - cross reference with jumpingFrames	Boolean	dying;	Boolean	gDead;	Boolean gOnLeftConveyor;	Boolean	gOnRightConveyor;	Boolean	gThrowingBanana;	short	delayToNextThrow;	short	teleporting;	short	teleportDirection;	short	enteredDoor;	short	framesInactive;	short	key;	short	heightFallen;	short	powerUp;	short	gPointsMultiplier;	short	multiplierTimer, shieldTimer, beanieTimer, fastFireTimer, powerFireTimer, multipleFireTimer, jetPackTimer;	short	numberOfBananas;	float	gDarwinLife, gDarwinStamina;	} PlayerSprite, *PlayerSpritePtr;typedef struct MonsterSprite {	Rect	theRect;	Boolean	directionFacing;	// 1 = left/up, 0 = right/down	Boolean	needToDraw;			// does the sprite need drawing ?	short	*source;			// addresses of gworlds	long	sourceRowBytes;	short	*dest;	short	kind;			// what type of sprite ?	short	subKind;	short	room;	short	frame;		short	frequency;	// to check for frequency of scripts	Boolean	directionMoving;	short	directionCount;	short	spriteType;	short	spriteMovement;	short	aggression;	short	maxSpeed;	short	frames;	short	hitPoints, maxHitPoints;	short	layer;	short	animationSpeed;	short	animationCounter;	short	bananaAction;	short	drawingHeight, drawingWidth;	short	inset;	struct MonsterSprite	*nextSprite, *prevSprite;	} MonsterSprite, *MonsterSpritePtr;typedef struct MonsterSpriteSave {	Rect	theRect;	Boolean	directionFacing;	// 1 = left/up, 0 = right/down	Boolean	needToDraw;			// does the sprite need drawing ?	short	*source;			// addresses of gworlds	long	sourceRowBytes;	short	*dest;	short	kind;			// what type of sprite ?	short	subKind;	short	room;	short	frame;		short	frequency;	// to check for frequency of scripts	Boolean	directionMoving;	short	directionCount;	short	spriteType;	short	spriteMovement;	short	aggression;	short	maxSpeed;	short	frames;	short	hitPoints, maxHitPoints;	short	layer;	short	animationSpeed;	short	animationCounter;	short	bananaAction;	short	drawingHeight, drawingWidth;	short	inset;	} MonsterSpriteSave, *MonsterSpriteSavePtr;typedef struct ItemSprite {	Rect	theRect;	Boolean	directionFacing;	// 1 = left/up, 0 = right/down	Boolean	needToDraw;			// does the sprite need drawing ?	short	*source;			// addresses of gworlds	long	sourceRowBytes;	short	*dest;	short	kind;			// what type of sprite ?	short	subKind;	short	room;	short	iconRow;	short	frame;	short	regenerateCountdown;	short	drawingHeight, drawingWidth;	Boolean	darwinOverlapping;	struct ItemSprite	*nextSprite, *prevSprite;	} ItemSprite, *ItemSpritePtr;typedef struct ItemSpriteSave {	Rect	theRect;	Boolean	directionFacing;	// 1 = left/up, 0 = right/down	Boolean	needToDraw;			// does the sprite need drawing ?	short	*source;			// addresses of gworlds	long	sourceRowBytes;	short	*dest;	short	kind;			// what type of sprite ?	short	subKind;	short	room;	short	iconRow;	short	frame;	short	regenerateCountdown;	short	drawingHeight, drawingWidth;	Boolean	darwinOverlapping;	} ItemSpriteSave, *ItemSpriteSavePtr;typedef struct TalismanSprite {	Rect	theRect;	Boolean	directionFacing;	// 1 = left/up, 0 = right/down	Boolean	needToDraw;			// does the sprite need drawing ?	short	*source;			// addresses of gworlds	long	sourceRowBytes;	short	*dest;	short	kind;	short	subKind;	short	room;	short	iconRow;	short	frame;	short	drawingHeight, drawingWidth;	struct TalismanSprite	*nextSprite, *prevSprite;	} TalismanSprite, *TalismanSpritePtr;typedef struct TalismanSpriteSave {	Rect	theRect;	Boolean	directionFacing;	// 1 = left/up, 0 = right/down	Boolean	needToDraw;			// does the sprite need drawing ?	short	*source;			// addresses of gworlds	long	sourceRowBytes;	short	*dest;	short	kind;	short	subKind;	short	room;	short	iconRow;	short	frame;	short	drawingHeight, drawingWidth;	} TalismanSpriteSave, *TalismanSpriteSavePtr;typedef struct SpringSprite {	short	subKind;	Rect	theRect;	short	iconRow;	short	frame;	short	hArray, vArray;	Boolean	artificiallySprung;	// for the springs to keep them synchronised	short	springDirection;	short	drawingHeight;	Boolean	needToDraw;			// does the sprite need drawing ?	short	*source;			// addresses of gworlds	short	*dest;	struct SpringSprite	*nextSprite, *prevSprite;	} SpringSprite, *SpringSpritePtr;typedef struct HazardSprite {	Rect	theRect;	Boolean	directionFacing;	// 1 = left/up, 0 = right/down	Boolean	needToDraw;			// does the sprite need drawing ?	short	*source;			// addresses of gworlds	long	sourceRowBytes;	short	*dest;	short	subKind;	short	hArray, vArray;	short	iconRow;	short	frame;	struct HazardSprite	*nextSprite, *prevSprite;	} HazardSprite, *HazardSpritePtr;typedef struct ConveyorSprite {	short	kind;			// what type of sprite ?	short	subKind;	short	frame;	short	iconRow;	Rect	theRect;	short	hArray, vArray;	Boolean	needToDraw;			// does the sprite need drawing ?	short	*source;			// addresses of gworlds	short	*dest;	struct ConveyorSprite	*nextSprite, *prevSprite;	} ConveyorSprite, *ConveyorSpritePtr;typedef struct DissolverSprite {	short	subKind;	Rect	theRect;	short	hArray, vArray;	short	frame;	short	iconRow;	short dissolverStatus;	short dissolverDirection;	Boolean	needToDraw;			// does the sprite need drawing ?	short	*source;			// addresses of gworlds	short	*dest;	struct DissolverSprite	*nextSprite, *prevSprite;	} DissolverSprite, *DissolverSpritePtr;typedef struct BananaSprite {	Rect	theRect;	Boolean	directionFacing;	// 1 = left/up, 0 = right/down	Boolean	needToDraw;			// does the sprite need drawing ?	short	*source;			// addresses of gworlds	long	sourceRowBytes;	short	*dest;	short	kind;			// what type of sprite ?	short	room;	short	bananaStatus;	short	frame;	float	speedh, speedv;	struct BananaSprite	*nextSprite, *prevSprite;	} BananaSprite, *BananaSpritePtr;// data structures for particlestypedef struct GWParticleWrapper {	short	numberOfParticles;	short	numberOfActiveParticles;	struct	GWParticle	*particleList;	struct	GWParticleWrapper	*nextParticle, *prevParticle;	} GWParticleWrapper, *GWParticleWrapperPtr;typedef struct GWParticle {	float	vert, horiz;	float	speedv, speedh;	short	color;	short	duration;	Boolean	active;	Boolean	needToDraw;	short	*dest;	struct	GWParticle	*nextParticle, *prevParticle;	} GWParticle, *GWParticlePtr;// for casting sprite types in collision routinestypedef struct CollisionSprite {	Rect	theRect;	Boolean	directionFacing;	// 1 = left/up, 0 = right/down	Boolean	needToDraw;			// does the sprite need drawing ?	short	*source;			// addresses of gworlds	long	sourceRowBytes;	} CollisionSprite, *CollisionSpritePtr;/* Prefs record */#ifdef	DEMOtypedef struct {	short			majorVersionNumber;	short			minorVersionNumber;	short			patchNumber;	short			soundVolume;	short			musicVolume;	GDHandle		prefsScreen;} PrefsRec, **PrefsHnd;#elsetypedef struct {	short			majorVersionNumber;	short			minorVersionNumber;	short			patchNumber;	long			serialNumber;	Str32			registerName;	long			registrationCode;	short			soundVolume;	short			musicVolume;	short			difficulty;	GDHandle		prefsScreen;} PrefsRec, **PrefsHnd;#endiftypedef	struct {	long	aSavedHighScore[10];	Str32	aName[10];} savedHighScores, *scorePtr, **scoreHandle;/* serial number record */typedef struct{	long			serialNumber;} SerialNumRec, **SerialNumHnd;// data types for creating spritestypedef struct{	short	probability;	// % probability - 100 = every time, 0 = use frequency instead	short	frequency;	// how often - 1 = every time. 2 = every other time, etc.		short	resourceID;	short	offsetH, offsetV;	short	directionFacing;		short	sound;	// 0 = none		short	destroyOriginal;	// do we destroy the original sprite ?	short	transferHitPoints;}	SCRT, **SCRTHandle;