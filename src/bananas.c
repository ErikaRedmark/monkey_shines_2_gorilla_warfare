#include	"globals extern.h"BananaSpritePtr DisposeBanana(BananaSpritePtr theSprite){	BananaSpritePtr	returnValue;	BananaSpritePtr	tempSprite = theSprite;	if (theSprite == nil) FatalError("Trying to dispose of zero sprite", true);	returnValue = theSprite->nextSprite;		if (theSprite->nextSprite == nil)	// must be the last banana in the list	{		if (theSprite == firstBanana) firstBanana = nil;	}	else if (theSprite == firstBanana)	{		firstBanana = theSprite->nextSprite;	}	if (tempSprite->nextSprite) (tempSprite->nextSprite)->prevSprite = tempSprite->prevSprite;	if (tempSprite->prevSprite) (tempSprite->prevSprite)->nextSprite = tempSprite->nextSprite;	DisposePtr( (Ptr)theSprite);	return returnValue;}// handle the thrown bananasvoid	HandleBananas(Rect *drawingRect){	BananaSpritePtr tempBanana = firstBanana;		while (tempBanana)	{		HandleOneBanana(tempBanana, drawingRect);		tempBanana = tempBanana->nextSprite;	}	// now do any need disposing ?		tempBanana = firstBanana;	while (tempBanana)	{		if (tempBanana->kind == kSpriteDone) tempBanana = DisposeBanana(tempBanana);		else tempBanana = tempBanana->nextSprite;	}}void HandleOneBanana(BananaSpritePtr theBanana,  Rect *drawingRect){	short	h,v;	Rect	dummy;	if (theBanana->bananaStatus ==  25) // changed from 47	{		CreateParticlesFromBanana(theBanana);		PlayASound(sndBananaExplodes);		theBanana->kind = kSpriteDone;		return;	}	theBanana->frame = (++(theBanana->frame)) % 8;	theBanana->bananaStatus++;			if (theBanana->speedh < 0)	{		short temp;				temp = TestMoveSpriteLeft(&theBanana->theRect, 0 - theBanana->speedh);			if (temp > 0) theBanana->theRect.left -= temp;		else theBanana->speedh *= -1;	}	else	{		short temp;				temp = TestMoveSpriteRight(&theBanana->theRect, theBanana->speedh);				if (temp > 0) theBanana->theRect.left += temp;		else theBanana->speedh *= -1;	}		// need to add bouncing off platforms vertically		if (theBanana->speedv < 0)	{		short temp = TestMoveSpriteUp(&theBanana->theRect, (short)(0 - theBanana->speedv));				if (temp > 0) theBanana->theRect.top -= temp;		else theBanana->speedv *= -1;	}	else if (theBanana->speedv > 0)	{		short temp;		Boolean blocked = TestMoveSpriteDown(&theBanana->theRect, (short)theBanana->speedv, &temp);				if (blocked) theBanana->speedv *= -1;		else theBanana->theRect.top += temp;	}	theBanana->theRect.right = theBanana->theRect.left + 24;	theBanana->theRect.bottom = theBanana->theRect.top + 24;	// gravity		theBanana->speedv += 0.2;	// check if the hazard is on the visible part of the screen	if (SectRect(drawingRect, &theBanana->theRect, &dummy)) theBanana->needToDraw = true;	else theBanana->needToDraw = false;		if (theBanana->room != theGlobals.theRoom) theBanana->needToDraw = false;	// if we don't need to draw it, nothing more to do		if (theBanana->needToDraw == false) return;		// now use h and v for the coordinates		h = theBanana->theRect.left - (24 * minActualHoriz);	v = theBanana->theRect.top - (24 * minActualVert);		theBanana->source = (short *)(theGWorlds.bananaMemPtr + (48 * theBanana->frame));	theBanana->dest = (short *)(theGWorlds.safeMemPtr + (v * theGWorlds.safeRowOffSet) + 2 * h);}