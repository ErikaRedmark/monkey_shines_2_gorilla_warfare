#include	"globals extern.h"#ifdef useProfiler#pragma profile on#endifvoid	LoadTileSprites ( void ){	short	i,j;	Rect	dummy;	// set the drawing port		PreCalculateVisibleRect(&dummy);	for (i = minRequiredHoriz; i <= maxRequiredHoriz; i++)	{		for (j = minRequiredVert; j <= maxRequiredVert; j++) DrawOneItem(i, j);	}		minActualHoriz = minRequiredHoriz;	minActualVert = minRequiredVert;	maxActualHoriz = maxRequiredHoriz;	maxActualVert = maxRequiredVert;}void	DrawThePlatforms ( void ){	short	i,j;		DrawParallaxLayer();	for (i = minActualHoriz; i <= maxActualHoriz; i++)	{		for (j = minActualVert; j <= maxActualVert; j++) DrawOnePlatform(i, j);	}}/*We need to draw another row, so the GWorld must be about to swap. Shouldbe drawn in whichever GWorld is NOT current.Draws the row in global coordinates of "rowToDraw"*/void	DrawOneRow(short rowToDraw){	short i;		for (i = minRequiredHoriz; i <= maxRequiredHoriz; i++) DrawOneItem(i, rowToDraw);}void	DrawOneColumn(short columnToDraw){	short i;	for (i = minRequiredVert; i <= maxRequiredVert; i++) DrawOneItem(columnToDraw, i);}/*Dispose of any sprites associated with a particular row*/void	DisposeOneRow(short rowToDispose){	SpringSpritePtr	tempSpring;	HazardSpritePtr	tempHazard;	ConveyorSpritePtr	tempConveyor;	DissolverSpritePtr	tempDissolver;	tempSpring = firstSpring;		while (tempSpring)	{		if (tempSpring->vArray == rowToDispose) tempSpring = DisposeSpring(tempSpring);		else tempSpring = tempSpring->nextSprite;	}	tempHazard = firstHazard;		while (tempHazard)	{		if (tempHazard->vArray == rowToDispose) tempHazard = DisposeHazard(tempHazard);		else tempHazard = tempHazard->nextSprite;	}	tempConveyor = firstConveyor;		while (tempConveyor)	{		if (tempConveyor->vArray == rowToDispose) tempConveyor = DisposeConveyor(tempConveyor);		else tempConveyor = tempConveyor->nextSprite;	}	tempDissolver = firstDissolver;		while (tempDissolver)	{		if (tempDissolver->vArray == rowToDispose)		{			SetOtherData(tempDissolver->hArray, tempDissolver->vArray, maskDissolver | tempDissolver->subKind);			tempDissolver = DisposeDissolver(tempDissolver);		}		else tempDissolver = tempDissolver->nextSprite;	}}/*Dispose of any sprites associated with a particular column*/void	DisposeOneColumn(short columnToDispose){	SpringSpritePtr	tempSpring;	HazardSpritePtr	tempHazard;	ConveyorSpritePtr	tempConveyor;	DissolverSpritePtr	tempDissolver;	tempSpring = firstSpring;		while (tempSpring)	{		if (tempSpring->hArray == columnToDispose) tempSpring = DisposeSpring(tempSpring);		else tempSpring = tempSpring->nextSprite;	}	tempHazard = firstHazard;		while (tempHazard)	{		if (tempHazard->hArray == columnToDispose) tempHazard = DisposeHazard(tempHazard);		else tempHazard = tempHazard->nextSprite;	}	tempConveyor = firstConveyor;		while (tempConveyor)	{		if (tempConveyor->hArray == columnToDispose) tempConveyor = DisposeConveyor(tempConveyor);		else tempConveyor = tempConveyor->nextSprite;	}	tempDissolver = firstDissolver;		while (tempDissolver)	{		if (tempDissolver->hArray == columnToDispose)		{			SetOtherData(tempDissolver->hArray, tempDissolver->vArray, maskDissolver | tempDissolver->subKind);			tempDissolver = DisposeDissolver(tempDissolver);		}		else tempDissolver = tempDissolver->nextSprite;	}}void	DrawOneItem(short i, short j){	short 			whatItem;	SpringSpritePtr	tempSpring;	ConveyorSpritePtr	tempConveyor;	DissolverSpritePtr	tempDissolver;	HazardSpritePtr		tempHazard;	whatItem = GetOtherData(i,j);	if (whatItem == 0) return;	// nothing more to do	if ((whatItem & (maskTalisman + maskItem)) != 0)	{		// part of the talisman or an item	}	else if (whatItem & maskSpring) // spring	{		tempSpring = AllocateSpring();		tempSpring->hArray = i;		tempSpring->vArray = j;		tempSpring->theRect.left = 24 * i;		tempSpring->theRect.top = (24 * j) - 24;		tempSpring->theRect.right = tempSpring->theRect.left + 24;		tempSpring->theRect.bottom = tempSpring->theRect.top + 48;		tempSpring->subKind = whatItem & 7;							// between 0 and 7		tempSpring->iconRow = 48 * tempSpring->subKind;		tempSpring->needToDraw = false;		tempSpring->springDirection = 0; // TODO - necessary ?	}	else if ((whatItem & (maskConveyorLeft + maskConveyorRight)) != 0) // dissolver, conveyor left + right	{		tempConveyor = AllocateConveyor();		tempConveyor->hArray = i;		tempConveyor->vArray = j;		tempConveyor->theRect.left = 24 * i;		tempConveyor->theRect.top = 24 * j;		tempConveyor->theRect.right = tempConveyor->theRect.left + 24;		tempConveyor->theRect.bottom = tempConveyor->theRect.top + 24;		tempConveyor->subKind = whatItem & 7;							// between 0 and 7		tempConveyor->iconRow = 24 * tempConveyor->subKind;		tempConveyor->needToDraw = false;		tempConveyor->kind = whatItem & (maskConveyorLeft + maskConveyorRight);	}	else if ((whatItem & maskDissolver) != 0) // dissolver, conveyor left + right	{		tempDissolver = AllocateDissolver();		tempDissolver->hArray = i;		tempDissolver->vArray = j;		tempDissolver->theRect.left = 24 * i;		tempDissolver->theRect.top = 24 * j;		tempDissolver->theRect.right = tempDissolver->theRect.left + 24;		tempDissolver->theRect.bottom = tempDissolver->theRect.top + 24;		tempDissolver->subKind = whatItem & 7;							// between 0 and 7		tempDissolver->iconRow = 24 * tempDissolver->subKind;		tempDissolver->needToDraw = false;		tempDissolver->dissolverStatus = 0; //  TODO - necessary ?	}	else if ((whatItem & maskHazard) != 0) // hazard, dissolver, conveyor left + right	{		tempHazard = AllocateHazard();		tempHazard->hArray = i;		tempHazard->vArray = j;		tempHazard->theRect.left = 24 * i;		tempHazard->theRect.top = 24 * j;		tempHazard->theRect.right = tempHazard->theRect.left + 24;		tempHazard->theRect.bottom = tempHazard->theRect.top + 24;		tempHazard->subKind = whatItem & 7;							// between 0 and 7		tempHazard->iconRow = 24 * tempHazard->subKind;		tempHazard->needToDraw = false;		tempHazard->sourceRowBytes = theGWorlds.hazardRowOffSet;	}}void	DrawOnePlatform(short i, short j){	short	*dest;	short	whatItem;	dest = (short *)(theGWorlds.safeMemPtr + (theGWorlds.safeRowOffSet * (24 * (j - minRequiredVert))) + (48 * (i - minRequiredHoriz)));	// scenery		whatItem = GetSceneryData(i,j);	if (whatItem) SmallBlit(sceneryAddresses[whatItem], theGWorlds.platformRowOffSet, dest);	// platforms on top		whatItem = GetPlatformData(i,j);		if (whatItem) SmallBlit(platformAddresses[whatItem], theGWorlds.platformRowOffSet, dest);}//original using CopyBits//average 7.065 msvoid	DrawParallaxLayer(void){	Rect 	srcRect, fullRect;	short	horiz, vert;	// work out which bit of the parallax GWorld to draw	horiz = player.theRect.left - (scrollOffsetH + (24 * minActualHoriz));	vert = player.theRect.top - (scrollOffsetV + (24 * minActualVert));	// fullRect is the part of the safeGWorld which wil actually be copied to the screen	// hand optimisation of numbers. see explanation in DoBlitting()	SetRect(&fullRect,	horiz - 252, vert - 144, horiz + 324, vert + 216);	// (horiz, vert) is the global coordinate (world coordinates) that this corresponds to	horiz = player.theRect.left - 252 - scrollOffsetH;	vert = player.theRect.top - 144 - scrollOffsetV;	// the coordinate of the parallax is this divided by the parallaxRatio	// for how far we have moved in the parallax world	horiz = horiz/parallaxRatioH;	vert = vert/parallaxRatioV;	// now clip this to the parallax GWorld size	horiz = horiz % pWidth;	vert = vert % pHeight;		SetRect(&srcRect, horiz, vert, horiz + 576, vert + 360);	// now a fancy blitter	{		long *source, *back, *dest;		long i, j, tempLong, temp1, temp2;		long sourceOffset, backOffset, destOffset;				dest = (long *)(theGWorlds.safeMemPtr + (2 * fullRect.left) + (theGWorlds.safeRowOffSet * fullRect.top)); 		source = (long *)(theGWorlds.parallaxMemPtr + (2 * srcRect.left) + (theGWorlds.parallaxRowOffSet * srcRect.top));		back = (long *)theGWorlds.parallaxBackMemPtr;		sourceOffset = theGWorlds.parallaxRowOffSet/4;		destOffset = theGWorlds.safeRowOffSet/4;		backOffset = theGWorlds.parallaxBackRowOffSet/4;				for (i = 0; i < 360; i++)		{			for (j = 0; j < 288; j++)			{				temp1 = source[j];				if (temp1 == 0x7FFF7FFF) tempLong = back[j]; // both pixels of foreground are white				else				{					if ((temp1 & 0x7FFF0000) == 0x7FFF0000)	// left pixel of foreground is white					{						temp2 = back[j];											tempLong = (temp1 & 0x00007FFF) | (temp2 & 0x7FFF0000);					}					else if ((temp1 & 0x00007FFF) == 0x00007FFF)	// right pixel of foreground is white					{						temp2 = back[j];											tempLong = (temp1 & 0x7FFF0000) | (temp2 & 0x00007FFF);					}					else tempLong = temp1; // neither pixel is white				}								dest[j] = tempLong;			}						source += sourceOffset;			dest += destOffset;			back += backOffset;		}	}//	CopyBits( &((GrafPtr)parallaxGWorld)->portBits, &((GrafPtr)safeGWorld)->portBits,  //		&srcRect, &fullRect, srcCopy, ( RgnHandle )0L );}#ifdef useProfiler#pragma profile off#endif