#include	"globals extern.h"void HandleMenuChoice(long menuChoice){	short menu, item;	long temp;		if (menuChoice != 0)	{		menu = HiWord(menuChoice);		item = LoWord(menuChoice);		switch (menu)		{			case 100:				CheckItem(theUserInterface.soundMenu, ((**gPrefs).soundVolume) + 1, false);				(**gPrefs).soundVolume = item - 1;				SetSoundVolume((**gPrefs).soundVolume);				PlayASound(sndVolumeFeedback);				CheckItem(theUserInterface.soundMenu, item, true);								// write out the modified preferences to disk										UpdatePreferences();				HiliteMenu(0);				break;			case 101:				CheckItem(theUserInterface.musicMenu, ((**gPrefs).musicVolume) + 1, false);				(**gPrefs).musicVolume = item - 1;				SetMusicVolume((**gPrefs).musicVolume);				CheckItem(theUserInterface.musicMenu, item, true);				// write out the modified preferences to disk										UpdatePreferences();				HiliteMenu(0);				break;			case 128:				HandleAppleChoice(item);				break;			case 129:				switch (item)				{					case 1:							// new game						temp = TickCount();						GWDelay(0, 10, false);						HiliteMenu(0);						NewGame(nil);						break;					case 2:						temp = TickCount();						GWDelay(0, 10, false);						HiliteMenu(0);						HideTheMenuBar();							CustomHideCursor();						KillControls(theUserInterface.theWindow);						HighScoreEventLoop(false, 11);						CustomHideCursor();						DrawControlScreen(true);						break;					case 3:	// clear high scores						ClearHighScores();						UpdatePreferences();												break;					case 4:	// set keys						ISpConfigure(nil);						break;					case 5:					case 6:						break;					case 7:						// this is "resume"						// shouldn't happen						break;					case 8:						break;					case 9:						temp = TickCount();						GWDelay(0, 10, false);						HiliteMenu(0);						theUserInterface.gQuit = true;						break;				}				break;		}		HideTheMenuBar();		}}void HandleAppleChoice(short item){	MenuHandle		appleMenu;	Str255			accName;	short			accNumber;	Rect			tempRect;	PicHandle tempPict;	switch (item)	{		case 1:	// about box			HideTheMenuBar();			SetRect(&tempRect,0, 0, 640, 480);			CopyBits( &((GrafPtr)(&theUserInterface.myCWindowRecord.port))->portBits, &((GrafPtr)theGWorlds.screenGWorld)->portBits, 					&tempRect, &tempRect, srcCopy, ( RgnHandle )0L );			UseResFile(theFileStuff.GWDataFileNumber);			tempPict = GetPicture(900);			if (tempPict == nil) FatalError("Error loading PICT 900", true);			DrawPicture(tempPict, &tempRect);						PlayASound(sndAboutBox);						ReleaseResource((Handle)tempPict);			UseResFile(theFileStuff.applicationFile);						while(!Button()) {}			CopyBits( &((GrafPtr)theGWorlds.screenGWorld)->portBits, &((GrafPtr)(&theUserInterface.myCWindowRecord.port))->portBits,					&tempRect, &tempRect, srcCopy, ( RgnHandle )0L );			break;		default:			appleMenu = GetMenuHandle(128);			GetMenuItemText(appleMenu, item, accName);			accNumber = OpenDeskAcc(accName);		break;	}}//____ StartupHideMenuBar __________________________________________________________________________////	Call this very early in your startup cycle; it saves off important information//	about the menubar.//void StartupHideMenuBar( void ){	GDHandle		mainDev, savedGD;	Rect			tempRect;	CGrafPtr		saved;	theUserInterface.savedGrayRgn = LMGetGrayRgn();		// Store the old gray region	theUserInterface.menuBarHeight = LMGetMBarHeight();	// Store the menu bar height//determine rectangle bounding the menubar so we can tell if//user has mouse-downed in it later	mainDev = GetMainDevice();		if (theUserInterface.gameGDevice != mainDev)	{		Rect			theDisplayBounds;		RgnHandle		workRgn;		GrafPtr			windowPort;		GrafPtr			oldPort;		CGrafPtr		windowCPort;		WindowPtr		frontWindow;			theDisplayBounds = (*theUserInterface.gameGDevice)->gdRect;	// Calculate the new regions		workRgn = NewRgn();		RectRgn( workRgn, &theDisplayBounds );		theUserInterface.newGrayRgn = NewRgn();		theUserInterface.coveredRgn = NewRgn();		UnionRgn( workRgn, theUserInterface.savedGrayRgn, theUserInterface.newGrayRgn );		DiffRgn( theUserInterface.newGrayRgn, theUserInterface.savedGrayRgn, theUserInterface.coveredRgn );		DisposeRgn( workRgn );			// Set the new gray region		LMSetGrayRgn( theUserInterface.newGrayRgn );			// Get the window manager port clip region		GetPort( &oldPort );		GetWMgrPort( &windowPort );		SetPort( windowPort );		SetClip( theUserInterface.newGrayRgn );				GetCWMgrPort( &windowCPort );		SetPort( ( GrafPtr )windowCPort );		SetClip( theUserInterface.newGrayRgn );			// Force an update of the desktop		PaintOne( nil, theUserInterface.newGrayRgn );			// Update the windows		frontWindow = FrontWindow();		PaintOne( ( WindowRef )frontWindow, theUserInterface.coveredRgn );		PaintBehind( ( WindowRef )frontWindow, theUserInterface.coveredRgn );		CalcVis( ( WindowRef )frontWindow );		CalcVisBehind( ( WindowRef )frontWindow, theUserInterface.coveredRgn );			// Restore the port		SetPort( oldPort );			return;	}	// don't need to hide menu bar if we		// aren't using the main screen		// just take the corners off the gray region		theUserInterface.menuBarRect = (**mainDev).gdRect;	theUserInterface.menuBarRect.bottom = theUserInterface.menuBarHeight;// set up a gworld to store the contents of the menu bar	SetRect(&tempRect, theUserInterface.menuBarRect.left, 0, theUserInterface.menuBarRect.right, theUserInterface.menuBarHeight);	NewGWorld(&theGWorlds.menuGWorld, 16, &tempRect, nil, nil, 0L);	theGWorlds.menuPixMap = GetGWorldPixMap(theGWorlds.menuGWorld);	MoveHHi((Handle)theGWorlds.menuPixMap);	LockPixels(theGWorlds.menuPixMap);		GetGWorld(&saved, &savedGD);	SetGWorld(theGWorlds.menuGWorld, nil);		ForeColor(blackColor);	PaintRect(&theGWorlds.menuGWorld->portRect);	SetGWorld(saved, savedGD);			}//StartupHideMenuBar//____ ShutdownHideMenuBar __________________________________________________________________________//////void ShutdownHideMenuBar( void ){//	if (gameGDevice != GetMainDevice()) return; // don't need to hide menu bar if we												// aren't using the main screen	LMSetGrayRgn( theUserInterface.savedGrayRgn );	// Restore the gray region !}//ShutdownHideMenuBar//____ HideMenuBar __________________________________________________________________________//////void HideTheMenuBar( void ){	GDHandle		mainDisplay;	Rect			theDisplayBounds;	RgnHandle		workRgn;	GrafPtr			windowPort;	GrafPtr			oldPort;	CGrafPtr		windowCPort;	WindowPtr		frontWindow;		// Make sure the menu bar is not already hidden	if ( theUserInterface.gMenuBarHidden )	return;	if (theUserInterface.gameGDevice != GetMainDevice()) return; // don't need to hide menu bar if we												// aren't using the main screen// Get the rectangle for the main display - CHANGED to any display		mainDisplay = GetMainDevice();	theDisplayBounds = (*mainDisplay)->gdRect;// Calculate the new regions	workRgn = NewRgn();	RectRgn( workRgn, &theDisplayBounds );	theUserInterface.newGrayRgn = NewRgn();	theUserInterface.coveredRgn = NewRgn();	UnionRgn( workRgn, theUserInterface.savedGrayRgn, theUserInterface.newGrayRgn );	DiffRgn( theUserInterface.newGrayRgn, theUserInterface.savedGrayRgn, theUserInterface.coveredRgn );	DisposeRgn( workRgn );	// Set the new gray region	LMSetGrayRgn( theUserInterface.newGrayRgn );	// Get the window manager port clip region	GetPort( &oldPort );	GetWMgrPort( &windowPort );	SetPort( windowPort );	SetClip( theUserInterface.newGrayRgn );		GetCWMgrPort( &windowCPort );	SetPort( ( GrafPtr )windowCPort );	SetClip( theUserInterface.newGrayRgn );	// Force an update of the desktop	PaintOne( nil, theUserInterface.newGrayRgn );	// Update the windows	frontWindow = FrontWindow();	PaintOne( ( WindowRef )frontWindow, theUserInterface.coveredRgn );	PaintBehind( ( WindowRef )frontWindow, theUserInterface.coveredRgn );	CalcVis( ( WindowRef )frontWindow );	CalcVisBehind( ( WindowRef )frontWindow, theUserInterface.coveredRgn );	// Mark the menu bar as hidden	LMSetMBarHeight( 0 );	theUserInterface.gMenuBarHidden = true;	// Restore the port	SetPort( oldPort );// paint in the menu bar with whatever was there before	CopyBits( &((GrafPtr)theGWorlds.menuGWorld)->portBits, (BitMap *)(*(*GetMainDevice())->gdPMap), 			&(theGWorlds.menuGWorld->portRect), &(theGWorlds.menuGWorld->portRect), 			srcCopy, ( RgnHandle )0L );}//HideMenuBar// store the contents of the menu bar, in case it was not void StoreMenuBar(void){	if (theUserInterface.gameGDevice != GetMainDevice()) return; // don't need to hide menu bar if we												// aren't using the main screen	CopyBits( (BitMap *)(*(*theUserInterface.gameGDevice)->gdPMap), &((GrafPtr)theGWorlds.menuGWorld)->portBits,			&(theGWorlds.menuGWorld->portRect), &(theGWorlds.menuGWorld->portRect), 			srcCopy, ( RgnHandle )0L );}//____ ShowMenuBar __________________________________________________________________________//////void ShowTheMenuBar( void ){	GDHandle	mainDisplay;	Rect		mainDisplayBounds;	WindowPtr	frontWindow;	GrafPtr		windowPort;	GrafPtr		oldPort;	CGrafPtr	windowCPort;	RgnHandle	workRgn;	// Make sure the menu bar is hidden		if ( !theUserInterface.gMenuBarHidden )	return;	if (theUserInterface.gameGDevice != GetMainDevice()) return; // don't need to hide menu bar if we												// aren't using the main screen	// save whatever was in the menu bar	// paint in the menu bar with whatever was there before	CopyBits( (BitMap *)(*(*theUserInterface.gameGDevice)->gdPMap), &((GrafPtr)theGWorlds.menuGWorld)->portBits,			&(theGWorlds.menuGWorld->portRect), &(theGWorlds.menuGWorld->portRect), 			srcCopy, ( RgnHandle )0L );// Get the rectangle for the main display	mainDisplay = GetMainDevice();	mainDisplayBounds = ( *mainDisplay )->gdRect;// Reset the menu bar height	LMSetMBarHeight( theUserInterface.menuBarHeight );	// Restore the gray region	LMSetGrayRgn( theUserInterface.savedGrayRgn );	// Recalculate the windows	frontWindow = FrontWindow();	CalcVis( ( WindowRef )frontWindow );	CalcVisBehind( ( WindowRef )frontWindow, theUserInterface.newGrayRgn );	// Reset the window manager port's clipping	GetPort( &oldPort );	GetWMgrPort( &windowPort );	SetPort( windowPort );	SetClip( theUserInterface.newGrayRgn );	GetCWMgrPort( &windowCPort );	SetPort( ( GrafPtr )windowCPort );	SetClip( theUserInterface.newGrayRgn );// paint the corners black	workRgn = NewRgn();	RectRgn( workRgn, &mainDisplayBounds );	DiffRgn(workRgn, theUserInterface.savedGrayRgn, workRgn);	ForeColor(blackColor);	PaintRgn(workRgn);	DisposeRgn(workRgn);	SetPort( oldPort );	// Redraw the menu bar	HiliteMenu( 0 );	DrawMenuBar();	// Mark that the menu bar is not hidden	theUserInterface.gMenuBarHidden = false;}//ShowMenuBar//____ CheckMenuHide __________________________________________________________________________////	This unhides or hides them menubar in certain situations:////	o	Mousedown in region where menubar would be - we show menu bar//	o	we're no longer the Foreground application - we show menu bar//	o	Mousedown _not_ in menubar region - we may hide the menubar//////	Call the when there's a context switch, or there's a mouse-down;//	Furthermore, call this after handling mouse-menu action to re-hide//	the menu bar;////	Pass in mouseDowns in global coordinates if there was a mousedown,//	otherwise, pass NULL//short CheckMenuHide( Point *mouseWhere ){	short	returnValue = 0;	if ((theUserInterface.gInBackGround) || ((NULL != mouseWhere ) && (PtInRect(*mouseWhere, &theUserInterface.menuBarRect))))	{		ShowTheMenuBar();		returnValue = 1;	}	else HideTheMenuBar();		return	returnValue;	}//CheckMenuHide