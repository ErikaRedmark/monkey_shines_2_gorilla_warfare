#include	"globals extern.h"// return value should be either the number of the room to move to, or 1000// if all lives have been lost// expand this later with codes for collecting all objects,...PlayerSprite			sparePlayer;				// sparePlayer used to remember where player came on screenvoid SetPlatformData(short i, short j, short whatItem);short	RunARoom(short whichDoor){	Boolean					done;	short					whatHappened, whichRoom;	DoorSpritePtr			tempDoor;	short					returnValue;	Boolean	teleportSound = false;	// work out which room is needed	#ifndef DEMO	if (!theFileStuff.saveFileInUse)	{#endif		tempDoor = firstDoor;				done = false;		while (!done)		{			if (tempDoor == nil)			{				// TODO - door not found error				FatalError("Door Not Found", true);				done = true;			}			else if (tempDoor->doorNumber == whichDoor)			{				done = true;				whichRoom = tempDoor->room;								if (tempDoor->doorNumber == 0)	// entry time machine				{					if (tempDoor->kind == maskDoorInactive)	// re-activate the entry time machine					{						tempDoor->kind = maskDoor;						tempDoor->frame = 5;						tempDoor->frameDirection = -1;					}					teleportSound = true;					canAbort = false;	// don't allow player to abort until Darwin has fully teleported in				}				else canAbort = true;			}			else tempDoor = tempDoor->nextSprite;		}		// initialise the player values, getting the start position from the door position			InitialisePlayerValues(tempDoor, whichRoom);#ifndef DEMO	}	else	{		whichRoom = theGlobals.theRoom;		// now close the save file down			theFileStuff.saveFileInUse = false;		CloseResFile(theFileStuff.saveResFile);	}#endif	saveMessageCounter = 0;	saveMessageTwoCounter = 0;	justSaved = false;	// load the world data into memory	if (roomLoaded != whichRoom) LoadRoomData(whichRoom);		/* save the player data */	// TODO - need to do this, or just re-initialise it ?	sparePlayer = player;		// load the sprites which are on the visible part of the screen		theGlobals.theRoom = whichRoom;	LoadTileSprites();	// resume input sprocket		ISpResume();#ifdef DEMO	WorldCheckFour(whichRoom);#endif	/* run until no lives are left or the player leaves the room */	done = false;	while (!done)	{		whatHappened = RunALife(teleportSound);			if (whatHappened == 999)		{			ItemSpritePtr tempItem;					theGlobals.gLivesLeft--;						tempItem = firstItem;					while (tempItem != nil)			{				if (tempItem->kind == maskItemInactive) tempItem->kind = maskItem;	// reset the shields and beanies				tempItem = tempItem->nextSprite;			}						RestoreKeyCopies();			// lost a life, so re-set required values.			player = sparePlayer;			player.gDead = false; player.gDarwinLife = 171; player.gDarwinStamina = 171;			player.gPointsMultiplier = 1; player.numberOfBananas = 20; player.multiplierTimer = 0;			player.beanieTimer = 0; player.shieldTimer = 0; player.fastFireTimer = 0;			player.powerFireTimer = 0; player.multipleFireTimer = 0; player.powerUp = noPowerUp;			DisposeRoomSprites();			if (theGlobals.gLivesLeft == 0)			{				done = true; // done !				DisposeRoomData();	// only need to dispose of room data at the end of a game, otherwise 									// a door may lead to another part of the same room			}			else			{				LoadTileSprites();				DoMessage();								DrawLivesLeft(); DrawLifeBar(); DrawStaminaBar();							// TODO - tempDoor should still be valid. Only do this if the player				// is teleporting in								if ((tempDoor->kind == maskDoorInactive) && (tempDoor->doorNumber == 0))	// re-activate the entry time machine				{					Rect	tempRect;									if (SectRect(&player.theRect, &(tempDoor->theRect), &tempRect))					{						tempDoor->kind = maskDoor;						tempDoor->frame = 5;						tempDoor->frameDirection = -1;						teleportSound = true;					}					else teleportSound = false;				}				else teleportSound = false;			}		}		else if (whatHappened == 32767)		{			// run a closing sequence - done in game loop						done = true;		}		else		{			// must have entered a door					DisposeRoomSprites();			StoreKeyCopies();			done = true;		}				sparePlayer = player; // store position of entry onto screen	}		if (theGlobals.gLivesLeft == 0) returnValue = 999;	else returnValue = whatHappened;	// door to jump to	ISpSuspend();	return returnValue;}void	LoadRoomData(short	whichRoom){#ifdef DEMO	RoomHandle	theRoomHandle;#endif	PicHandle	tempPict;	Rect		tempRect;	short		numberHoriz, numberVert;	short		i, j;	DoorSpritePtr	tempDoor;		// at this point the world file is open, and is the current resource file	// make sure there isn't a room loaded		if (roomLoaded != -1) DisposeRoomData();	firstSpring = nil;	firstHazard = nil;	firstConveyor = nil;	firstDissolver = nil;	firstBanana = nil;	firstParticle = nil;	lastParticle = nil;	// first the room resource#ifdef DEMO	theRoomHandle = (RoomHandle)Get1Resource('room', 128 + whichRoom);	if ((theRoomHandle == nil) || (ResError() != noErr)) FatalError("Error loading room data", true);#else	theRoomData = (short **)Get1Resource('rDta', 128 + whichRoom);	if ((theRoomData == nil) || (ResError() != noErr))	FatalError("Error loading room data", true);#endif#ifdef DEMO	roomWidthTiles = (**theRoomHandle).width;	roomHeightTiles = (**theRoomHandle).height;#else	roomWidthTiles = (**(RoomHandle)theRoomData).width;	roomHeightTiles = (**(RoomHandle)theRoomData).height;#endif		roomWidthPixels = roomWidthTiles * 24;	roomHeightPixels = roomHeightTiles * 24;#ifdef DEMO	parallaxRatioH = (**theRoomHandle).parallaxH;	parallaxRatioV = (**theRoomHandle).parallaxV;#else	parallaxRatioH = (**(RoomHandle)theRoomData).parallaxH;	parallaxRatioV = (**(RoomHandle)theRoomData).parallaxV;#endif	// parallax backdrop#ifdef DEMO	tempPict = GetPicture((**theRoomHandle).backgroundPICT);#else	tempPict = GetPicture((**(RoomHandle)theRoomData).backgroundPICT);#endif	if (tempPict == nil) FatalError("Error loading background PICT", true);	SetGWorld(theGWorlds.parallaxBackGWorld, nil);	DrawPicture(tempPict, &(theGWorlds.parallaxBackGWorld->portRect));	ReleaseResource((Handle)tempPict);		// load the parallax tile for the room#ifdef DEMO	tempPict = GetPicture((**theRoomHandle).parallaxPICT);#else	tempPict = GetPicture((**(RoomHandle)theRoomData).parallaxPICT);#endif	if (tempPict == nil) FatalError("Error loading parallaxPICT", true);		pWidth = (**tempPict).picFrame.right;	pHeight = (**tempPict).picFrame.bottom;		SetRect(&tempRect, 0, 0, pWidth, pHeight);	// make the parallax GWorld big enough to do one blit no matter what	numberVert = 360/pHeight;	numberHoriz = 576/pWidth;		numberVert += 2;	numberHoriz += 2;	SetRect(&tempRect, 0, 0, 576 + pWidth, 360 + pHeight);	NewGWorld(&theGWorlds.parallaxGWorld, 16, &tempRect, nil, nil, 0L);	theGWorlds.parallaxPixMap = GetGWorldPixMap(theGWorlds.parallaxGWorld);	MoveHHi((Handle)theGWorlds.parallaxPixMap);	LockPixels(theGWorlds.parallaxPixMap);	theGWorlds.parallaxMemPtr = (Byte *)GetPixBaseAddr(theGWorlds.parallaxPixMap);	theGWorlds.parallaxRowOffSet = (0x7FFF & (**theGWorlds.parallaxPixMap).rowBytes);	SetGWorld(theGWorlds.parallaxGWorld, nil);	for (i = 0; i < numberHoriz; i++)	{		for (j = 0; j < numberVert; j++)		{			SetRect(&tempRect, i * (**tempPict).picFrame.right, j * (**tempPict).picFrame.bottom,							(i + 1) * (**tempPict).picFrame.right, (j + 1) * (**tempPict).picFrame.bottom);			DrawPicture(tempPict, &tempRect);				}	}	ReleaseResource((Handle)tempPict);		// we've finished with the room resource#ifdef DEMO	ReleaseResource((Handle)theRoomHandle);#endif#ifdef DEMO	WorldCheckFive(whichRoom);#else	HackCheckThree();	CheckRegistrationThree();#endif#ifdef DEMO	theWorldScenery = (short **)Get1Resource('wDta', 128 + (3 * whichRoom));	if ((theWorldScenery == nil) || (ResError() != noErr))	FatalError("Error loading scenery", true);	theWorldPlatforms = (short **)Get1Resource('wDta', 129 + (3 * whichRoom));	if ((theWorldPlatforms == nil) || (ResError() != noErr))	FatalError("Error loading platforms", true);	WorldCheckSix();	theWorldOther = (short **)Get1Resource('wDta', 130 + (3 * whichRoom));	if ((theWorldOther == nil) || (ResError() != noErr))	FatalError("Error loading misc data", true);#endif#ifdef DEMO	WorldCheckSeven();#endif		// sort out the doors		tempDoor = firstDoor;		while (tempDoor)	{		if (tempDoor->room == whichRoom)		{			if ((tempDoor->subKind > 1) && (tempDoor->subKind < 6))			{				if (tempDoor->frame == 0)				{					for (j = 0; j < 3; j++)					{						SetPlatformData(tempDoor->hArray, tempDoor->vArray + j, 16); // door initially closed										}				}			}			else if (tempDoor->subKind == 7)			{				if (tempDoor->frame == 0)				{					for (j = 0; j < 3; j++)					{						SetPlatformData(tempDoor->hArray, tempDoor->vArray + j, 16); // door initially closed										}				}			}		}				tempDoor = tempDoor->nextSprite;	}	#ifndef DEMO	if (!gRegistered) FatalError("Room data corrupt", true);#endif	roomLoaded = whichRoom;}void	DisposeRoomSprites(void){	SpringSpritePtr	tempSpring;	HazardSpritePtr	tempHazard;	ConveyorSpritePtr	tempConveyor;	DissolverSpritePtr	tempDissolver;	BananaSpritePtr		tempBanana;	GWParticleWrapperPtr	tempParticle;	// dispose of all the sprites	tempSpring = firstSpring;	while (tempSpring) tempSpring = DisposeSpring(tempSpring);	tempHazard = firstHazard;	while (tempHazard) tempHazard = DisposeHazard(tempHazard);	tempConveyor = firstConveyor;	while (tempConveyor) tempConveyor = DisposeConveyor(tempConveyor);	tempDissolver = firstDissolver;	while (tempDissolver)	{		SetOtherData(tempDissolver->hArray, tempDissolver->vArray, maskDissolver | tempDissolver->subKind);		tempDissolver = DisposeDissolver(tempDissolver);	}	tempBanana = firstBanana;	while (tempBanana) tempBanana = DisposeBanana(tempBanana);	// dispose of all the particles	tempParticle = firstParticle;	while (tempParticle) tempParticle = DisposeParticle(tempParticle);		firstSpring = nil;	firstHazard = nil;	firstConveyor = nil;	firstDissolver = nil;	firstBanana = nil;	firstParticle = nil;	lastParticle = nil;}void	DisposeRoomData(void){	if (roomLoaded == -1) return;#ifdef DEMO	ReleaseResource((Handle)theWorldScenery);	ReleaseResource((Handle)theWorldPlatforms);	ReleaseResource((Handle)theWorldOther);#else	ReleaseResource((Handle)theRoomData);#endif		DisposeGWorld(theGWorlds.parallaxGWorld); // allocated within LoadRoomData	roomLoaded = -1; // none loaded}void	InitialisePlayerValues(DoorSpritePtr theDoor, short ){	// now stuff for the player#ifndef DEMO		if (theFileStuff.saveFileInUse)	{		// will have been loaded in LoadGame();	}	else	{#endif		player.speedh = 0;		player.speedv = 0;				scrollOffsetH = 0;		scrollOffsetV = 0;		player.door = theDoor;		if (theDoor->subKind == 0)	// TIME MACHINE		{			// get Darwin's starting position based on the door						player.teleporting = 4;	// teleporting in with time machine			player.teleportDirection = 1 + theDoor->darwinDoor;			player.iconRow = timeMachineRow;			player.frame = 14;	// no Darwin yet			player.theRect.left = theDoor->theRect.left + ((theDoor->theRect.right - theDoor->theRect.left)/2) - darwinWidth/2;			player.theRect.top = theDoor->theRect.bottom - (darwinHeight + 6);	// the door is not on the boundary		}		else		{			player.teleporting = 2;			player.teleportDirection = 1 + theDoor->darwinDoor;			player.iconRow = teleportRow;			player.frame = 21;			player.theRect.left = theDoor->theRect.left + ((theDoor->theRect.right - theDoor->theRect.left)/2) - darwinWidth/2;			player.theRect.top = theDoor->theRect.bottom - darwinHeight;		}				// TODO - another option for returning from a save point				player.theRect.bottom = player.theRect.top + darwinHeight;		player.theRect.right = player.theRect.left + darwinWidth;		player.sourceRowBytes = theGWorlds.darwinRowOffSet;		// the actual coordinates				player.posh = player.theRect.left;		/* some other initialisations */		player.directionFacing = directionRight;				player.darwinTired = false;		player.movingVertically = false;		// need to set these, or Darwin will start the next game doing whatever he		// finished the previous game doing		player.gLanding = false;		player.gJumpingFrames = false;				player.heightFallen = 0;		if (player.gDead)		{			player.gDead = false;			player.gDarwinLife = 171;			player.gDarwinStamina = 171;			player.gPointsMultiplier = 1;		#ifndef DEMO			if (theGlobals.difficulty == 0) player.numberOfBananas = 50;			else player.numberOfBananas = 20;		#else			player.numberOfBananas = 20;		#endif					player.multiplierTimer = 0;			player.shieldTimer = 0;			player.beanieTimer = 0;			player.fastFireTimer = 0;			player.powerFireTimer = 0;			player.multipleFireTimer = 0;			player.powerUp = noPowerUp;		}				player.dying = false;#ifndef DEMO	}#endif}