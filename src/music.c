#include	"globals extern.h"//#include	"Audio CD.h"MADLibrary	*MADLib;void 				OSType2Ptr( OSType type, Ptr str);void				RestartMusic(SndChannelPtr whichChannel);FilePlayCompletionUPP	soundCallback;//#define NewFilePlayCompletionProc(userRoutine) 					(FilePlayCompletionUPP)NewRoutineDescriptor((ProcPtr)(userRoutine), uppFilePlayCompletionProcInfo, GetCurrentArchitecture())void StartInterfaceMusic(void){	MADDriverSettings	init;	FSSpec				fileSpec;	FInfo				theInfo;	char				type[5];	OSErr				theError;	short				j;	MADGetBestDriver(&init);		init.repeatMusic = true;	init.MicroDelaySize = 0;	if( MADInitLibrary( "Plugs", false, &MADLib) != noErr) FatalError("Problem starting music library", true);	if( MADCreateDriver( &init, MADLib, &theAudioStuff.GWMusicDriver) != noErr) FatalError("Problem creating music driver", true);	theAudioStuff.madLibraryLoaded = true;	/* load the first music */#ifdef DEMO	theError = FSMakeFSSpec(theFileStuff.GWvolRef, theFileStuff.GWParentDirID, "\pGorilla Warfare Demo Music", &fileSpec); 	theError = FindFile(theFileStuff.GWParentDirID, "\pGorilla Warfare Demo Music", &fileSpec);#else	theError = FSMakeFSSpec(theFileStuff.GWvolRef, theFileStuff.GWParentDirID, "\pGorilla Warfare Music", &fileSpec); 	theError = FindFile(theFileStuff.GWParentDirID, "\pGorilla Warfare Music", &fileSpec);#endif	FSpGetFInfo(&fileSpec, &theInfo);	OSType2Ptr(theInfo.fdType, type);		if( MADPlugAvailable(MADLib, type))		// Is available a plug to open this file?	{		if( MADLoadMusicFSpFile(MADLib, &theAudioStuff.GWMusic, type, &fileSpec) == noErr)		// Load this music with help of Plugs																				// in application folder, in 'Plugs' folder or internal resources		{			MADAttachDriverToMusic(theAudioStuff.GWMusicDriver, theAudioStuff.GWMusic, 0L);		}		#ifndef DEMO			theAudioStuff.musicType = typeMADH;		#endif	}#ifndef DEMO	else	{		short	refNum;		SndCommand	mySndCmd;		FSpOpenDF(&fileSpec, fsRdPerm, &refNum);				theAudioStuff.fileOpen = true;		theAudioStuff.fileRefNum = refNum;		mySndCmd.param1 = 0;		mySndCmd.param2 = ((**gPrefs).musicVolume * 2097152) + ((**gPrefs).musicVolume * 32);		mySndCmd.cmd = volumeCmd;		SndDoImmediate(theAudioStuff.musicChannel, &mySndCmd);				soundCallback = NewFilePlayCompletionProc(RestartMusic);		SndStartFilePlay (theAudioStuff.musicChannel, refNum, nil, 20480, nil, nil, soundCallback, true);		theAudioStuff.musicPlaying = interfaceMusic;		theAudioStuff.restartMusic = false;	/*	SndStartFilePlay (chan: SndChannelPtr; fRefNum: Integer;                                  resNum: Integer; bufferSize: LongInt;                                  theBuffer: Ptr;                                   theSelection: AudioSelectionPtr;                                   theCompletion: ProcPtr;                                   async: Boolean): OSErr; */			theAudioStuff.musicType = typeAIFF;	}#endif#ifndef DEMO	if (theAudioStuff.musicType == typeMADH)	{#endif		SetMusicVolume(0);		MADStartDriver(theAudioStuff.GWMusicDriver);	// Turn interrupt driver function ON		MADPlayMusic(theAudioStuff.GWMusicDriver);		// Read the current partition in memory			theAudioStuff.musicPlaying = interfaceMusic;		// now fade it in		for (j = 0; j < 64; j++)		{			if ((theAudioStuff.GWMusicDriver)->VolGlobal < ((**gPrefs).musicVolume * 8)) (theAudioStuff.GWMusicDriver)->VolGlobal++;			GWDelay(0, 2, false);		}#ifndef DEMO	}	else	{		if (theAudioStuff.madLibraryLoaded)		{			MADDisposeDriver(theAudioStuff.GWMusicDriver);	// Dispose music driver			MADDisposeLibrary(MADLib);						// Close music library		}				theAudioStuff.madLibraryLoaded = false;	}#endif}void StopInterfaceMusic(void){	short		j;#ifndef DEMO	if (theAudioStuff.musicType == typeMADH)	{#endif		for (j = 0; j < 64; j++)		{			if ((theAudioStuff.GWMusicDriver)->VolGlobal > 0) (theAudioStuff.GWMusicDriver)->VolGlobal--;			GWDelay(0, 1, false);		}				// stop the current music				MADStopMusic(theAudioStuff.GWMusicDriver);		// Stop reading current partition		MADStopDriver(theAudioStuff.GWMusicDriver);		// Stop driver interrupt function		MADDisposeMusic(&theAudioStuff.GWMusic, theAudioStuff.GWMusicDriver);		// Dispose the current music		theAudioStuff.musicPlaying = noMusic;				if (theAudioStuff.madLibraryLoaded)		{			MADDisposeDriver(theAudioStuff.GWMusicDriver);	// Dispose music driver			MADDisposeLibrary(MADLib);						// Close music library		}				theAudioStuff.madLibraryLoaded = false;#ifndef DEMO	}	else	{		if (theAudioStuff.fileOpen)		{			SndStopFilePlay(theAudioStuff.musicChannel, true);			theAudioStuff.musicPlaying = noMusic;			FSClose(theAudioStuff.fileRefNum);			theAudioStuff.fileOpen = false;			DisposeRoutineDescriptor(soundCallback);		}	}#endif}void	StartGameMusic(void){	short			wasResFile;	MADDriverSettings	init;	OSErr				theError;	FSSpec				fileSpec;	FInfo				theInfo;	char				type[5];	short				j;#ifndef DEMO	StringHandle		musicFileName;#endif	wasResFile = CurResFile();	MADGetBestDriver( &init);		init.repeatMusic = true;	init.MicroDelaySize = 0;	if( MADInitLibrary( "Plugs", false, &MADLib) != noErr) FatalError("Problem starting music library", true);	if( MADCreateDriver( &init, MADLib, &theAudioStuff.GWMusicDriver) != noErr) FatalError("Problem creating music driver", true);	theAudioStuff.madLibraryLoaded = true;	/* load the first music */#ifdef DEMO	theError = FSMakeFSSpec(theFileStuff.GWvolRef, theFileStuff.GWParentDirID, "\pLava P'Lava Demo Music", &fileSpec); 	theError = FindFile(theFileStuff.GWParentDirID, "\pLava P'Lava Demo Music", &fileSpec);#else	UseResFile(theFileStuff.worldFile);	musicFileName = GetString(129);	theError = FSMakeFSSpec(theFileStuff.GWvolRef, theFileStuff.GWParentDirID, *musicFileName, &fileSpec); 	theError = FindFile(theFileStuff.GWParentDirID, *musicFileName, &fileSpec);#endif	FSpGetFInfo(&fileSpec, &theInfo);	OSType2Ptr(theInfo.fdType, type);		if( MADPlugAvailable(MADLib, type))		// Is available a plug to open this file?	{		if( MADLoadMusicFSpFile(MADLib, &theAudioStuff.GWMusic, type, &fileSpec) == noErr)		// Load this music with help of Plugs																				// in application folder, in 'Plugs' folder or internal resources		{			MADAttachDriverToMusic(theAudioStuff.GWMusicDriver, theAudioStuff.GWMusic, 0L);		}	}#ifndef DEMO	else	{		short	refNum;		SndCommand	mySndCmd;		FSpOpenDF(&fileSpec, fsRdPerm, &refNum);		theAudioStuff.fileOpen = true;		theAudioStuff.fileRefNum = refNum;		mySndCmd.param1 = 0;		mySndCmd.param2 = ((**gPrefs).musicVolume * 2097152) + ((**gPrefs).musicVolume * 32);		mySndCmd.cmd = volumeCmd;		SndDoImmediate(theAudioStuff.musicChannel, &mySndCmd);		soundCallback = NewFilePlayCompletionProc(RestartMusic);		SndStartFilePlay (theAudioStuff.musicChannel, refNum, nil, 20480, nil, nil, soundCallback, true);		theAudioStuff.musicPlaying = gameMusic;		theAudioStuff.restartMusic = false;	/*	SndStartFilePlay (chan: SndChannelPtr; fRefNum: Integer;                                  resNum: Integer; bufferSize: LongInt;                                  theBuffer: Ptr;                                   theSelection: AudioSelectionPtr;                                   theCompletion: ProcPtr;                                   async: Boolean): OSErr; */			theAudioStuff.musicType = typeAIFF;	}#endif#ifndef DEMO		if (theAudioStuff.musicType == typeMADH)	{#endif		SetMusicVolume(0);		MADStartDriver(theAudioStuff.GWMusicDriver);	// Turn interrupt driver function ON		MADPlayMusic(theAudioStuff.GWMusicDriver);		// Read the current partition in memory			theAudioStuff.musicPlaying = gameMusic;		// now fade it in		for (j = 0; j < 64; j++)		{			if ((theAudioStuff.GWMusicDriver)->VolGlobal < ((**gPrefs).musicVolume * 8)) (theAudioStuff.GWMusicDriver)->VolGlobal++;			GWDelay(0, 2, false);		}#ifndef DEMO	}	else	{		if (theAudioStuff.madLibraryLoaded)		{			MADDisposeDriver(theAudioStuff.GWMusicDriver);	// Dispose music driver			MADDisposeLibrary(MADLib);						// Close music library		}				theAudioStuff.madLibraryLoaded = false;	}#endif#ifndef DEMO	ReleaseResource((Handle)musicFileName);#endif	UseResFile(wasResFile);}void StopGameMusic(void){	short		j;#ifndef DEMO	if (theAudioStuff.musicType == typeMADH)	{#endif		for (j = 0; j < 64; j++)		{			if ((theAudioStuff.GWMusicDriver)->VolGlobal > 0) (theAudioStuff.GWMusicDriver)->VolGlobal--;			GWDelay(0, 1, false);		}				// stop the current music				MADStopMusic(theAudioStuff.GWMusicDriver);		// Stop reading current partition		MADStopDriver(theAudioStuff.GWMusicDriver);		// Stop driver interrupt function		MADDisposeMusic(&theAudioStuff.GWMusic, theAudioStuff.GWMusicDriver);		// Dispose the current music		theAudioStuff.musicPlaying = noMusic;				if (theAudioStuff.madLibraryLoaded)		{			MADDisposeDriver(theAudioStuff.GWMusicDriver);	// Dispose music driver			MADDisposeLibrary(MADLib);						// Close music library		}				theAudioStuff.madLibraryLoaded = false;#ifndef DEMO	}	else	{		if (theAudioStuff.fileOpen)		{			SndStopFilePlay(theAudioStuff.musicChannel, true);			theAudioStuff.musicPlaying = noMusic;			FSClose(theAudioStuff.fileRefNum);			theAudioStuff.fileOpen = false;			DisposeRoutineDescriptor(soundCallback);		}	}#endif}void	PauseGameMusic(void){#ifndef DEMO	if (theAudioStuff.musicType == typeMADH)	{#endif		MADStopMusic(theAudioStuff.GWMusicDriver);		// Stop reading current partition		SetMusicVolume(0);#ifndef DEMO	}	else	{		SndPauseFilePlay(theAudioStuff.musicChannel);	}#endif}void	ResumeGameMusic(void){#ifndef DEMO	if (theAudioStuff.musicType == typeMADH)	{#endif		MADPlayMusic(theAudioStuff.GWMusicDriver);		// Stop reading current partition		SetMusicVolume((**gPrefs).musicVolume);#ifndef DEMO	}	else	{		SndPauseFilePlay(theAudioStuff.musicChannel);	}#endif}void	StopMusic(void){	if (theAudioStuff.musicPlaying == noMusic)	{		// don't need to do anything	}	else if (theAudioStuff.musicPlaying == interfaceMusic) StopInterfaceMusic();	else if (theAudioStuff.musicPlaying == gameMusic) StopGameMusic();}void	SetMusicVolume(short volume){	SndCommand	mySndCmd;	if (volume < 0) volume = 0;	if (volume > 8) volume = 8;	if (theAudioStuff.madLibraryLoaded) (theAudioStuff.GWMusicDriver)->VolGlobal = volume << 3;	mySndCmd.param1 = 0;	mySndCmd.param2 = (volume * 2097152) + (volume * 32);	mySndCmd.cmd = volumeCmd;	SndDoImmediate(theAudioStuff.musicChannel, &mySndCmd);}void MusicVolumeDialog(void){	Rect		itemRect, tempRect;	short		itemType, itemHit;	DialogPtr	theDialog;	Handle		okItemHandle;	RgnHandle	theRegion;	ModalFilterUPP	myModalFilter;	short		tempMusicVolume;	// regcode is the calculated code for this name/number combo	Boolean dialogDone = false;	UseResFile(theFileStuff.GWDataFileNumber);	theDialog = GetNewDialog(15002, nil, (WindowPtr) -1L);	GetDialogItem(theDialog, ok, &itemType, &okItemHandle, &itemRect);		dialogDone = false;	SetPort(theDialog);	DrawDialog(theDialog);	theUserInterface.soundSliderBar = GetNewControl(1000, theDialog);			SetControlValue(theUserInterface.soundSliderBar, (**gPrefs).musicVolume);	ShowControl(theUserInterface.soundSliderBar);    BeginUpdate(theDialog);    EndUpdate(theDialog);	FlushEvents(everyEvent,0);	SetDialogDefaultItem(theDialog, ok);	SetDialogCancelItem(theDialog, cancel);	myModalFilter = NewModalFilterProc((RoutineDescriptor *)&MyMusicSliderEventFilter);	Draw1Control(theUserInterface.soundSliderBar);	while (!dialogDone)	{		ModalDialog(myModalFilter, &itemHit);		switch (itemHit)		{			case ok:			case cancel:				dialogDone = true;				break;		}				tempMusicVolume = GetControlValue((ControlHandle)theUserInterface.soundSliderBar);	}		DisposeRoutineDescriptor(myModalFilter);	DisposeControl(theUserInterface.soundSliderBar);		DisposeDialog(theDialog);	SetGWorld(&theUserInterface.myCWindowRecord.port, GetMainDevice());	// update the window behind the control	theRegion = theUserInterface.theWindow->visRgn;		tempRect.left = (**theRegion).rgnBBox.left;	tempRect.right = (**theRegion).rgnBBox.right;	tempRect.top = (**theRegion).rgnBBox.top;	tempRect.bottom = (**theRegion).rgnBBox.bottom;		CopyBits(&((GrafPtr)theGWorlds.screenGWorld)->portBits, &((GrafPtr)(&theUserInterface.myCWindowRecord.port))->portBits,		&tempRect, &tempRect,  srcCopy, ( RgnHandle )0L );			UpdateControls(theUserInterface.theWindow, theRegion);	UseResFile(theFileStuff.applicationFile);	if (itemHit != cancel)	{		CheckItem(theUserInterface.musicMenu, ((**gPrefs).musicVolume) + 1, false);		(**gPrefs).musicVolume = tempMusicVolume;		UpdatePreferences();				SetMusicVolume((**gPrefs).musicVolume);		CheckItem(theUserInterface.musicMenu, ((**gPrefs).musicVolume) + 1, true);	}	else SetMusicVolume((**gPrefs).musicVolume);	// hit cancel, so restore the sound volume	SetCCursor(theUserInterface.myCursor);}void OSType2Ptr( OSType type, Ptr str){	BlockMove( &type, str, 4);	str[ 4] = 0;}#ifndef DEMOvoid RestartMusic(SndChannelPtr ){	theAudioStuff.restartMusic = true;}#endif