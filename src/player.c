#include	"globals extern.h"short	movingLeft, movingRight, jumping, throwing, running;void GetPlayersAction(){	UInt32	input;	//¥	Check the movement axis	ISpElement_GetSimpleState(gInputElements[darwinMovement], &input);	movingLeft = 0;	movingRight = 0;		if (input < 0x2FFFFFFF) movingLeft = 1;	else if (input > 0xBFFFFFFF) movingRight =  1;			jumping = IsButtonHeld(gInputElements[darwinJump]);	throwing = IsButtonHeld(gInputElements[darwinThrow]);	running = IsButtonHeld(gInputElements[darwinRun]);		if (WasButtonPressed(gInputElements[abortLife]))	{		if (canAbort) player.gDead = true;	}		if (WasButtonPressed(gInputElements[abortGame]))	{		if (canAbort)		{			player.gDead = true;			theGlobals.gLivesLeft = 1;		}	}	if (WasButtonPressed(gInputElements[saveGame]))	{		if (CheckCanSave())		{			#ifdef	DEMO				saveMessageTwoCounter = 60;			#else				SaveGame();				saveMessageCounter = 0;			#endif		}		else saveMessageCounter = 60;	// 2 seconds	}	if (WasButtonPressed(gInputElements[quitGame]))	{		SetGWorld(&theUserInterface.myCWindowRecord.port, GetMainDevice());		CloseWorldFile();				SetEventMask(everyEvent - keyUpMask);		LMSetSysEvtMask(everyEvent - keyUpMask);		FlushEvents( keyDownMask + autoKeyMask, 0 );	// get rid of key presses		CustomShowCursor();		CleanUpAndQuit();		ExitToShell();	}		if (WasButtonPressed(gInputElements[screenshot]))  SavePixMap(*theUserInterface.myCWindowRecord.port.portPixMap);	if (WasButtonPressed(gInputElements[pause])) PauseGame();}Boolean	CheckCanSave(void){	DoorSpritePtr		tempDoor;	Rect				dummy;	Boolean		canSave = false;		tempDoor = firstDoor;		while (tempDoor)	{		if ((tempDoor->subKind == 6) && (SectRect(&player.theRect, &tempDoor->theRect, &dummy))) canSave = true;				tempDoor = tempDoor->nextSprite;	}	return canSave;}void HandlePlayer(){	short	dummy;	float	maxSpeed;	Rect	testRect;	GetPlayersAction();	if (player.teleporting) HandleTeleport();	if (player.teleporting) return;		// now work out what the speed is		if ((running) && (player.darwinTired == false))	{		maxSpeed = runSpeed;				if ((player.speedh < -(walkSpeed + 0.2)) || (player.speedh > (walkSpeed + 0.2)))		{			player.gDarwinStamina -= 0.2;			DrawStaminaBar();						if (player.gDarwinStamina < 0.1)			{				player.gDarwinStamina = 0.1; // can't die from running				player.darwinTired = true;				player.frame = 0;				maxSpeed = walkSpeed; // can't run any more			}		}			}	else maxSpeed = walkSpeed;		if (player.numberOfBananas == 0) throwing = 0; // override this if no bananas		if ((!(movingLeft)) && (!(movingRight))) maxSpeed = 0;	// slow down to stop		if (movingLeft && (player.speedh > -maxSpeed)) player.speedh -= accel;	// accelerate left	else if (movingRight && (player.speedh < maxSpeed)) player.speedh += accel;	// accelerate right	else if (movingLeft && (player.speedh < -maxSpeed)) player.speedh += accel;	// slow down left	else if (movingRight && (player.speedh > maxSpeed)) player.speedh -= accel;	// slow down right	else if (maxSpeed == 0)	{		// not trying to move any direction, so slow down to stop				if (player.speedh < 0) player.speedh += accel;		else if (player.speedh > 0) player.speedh -= accel;				// allow for errors in floating point				if ((player.speedh > -0.12) && (player.speedh < 0.12)) player.speedh = 0;	}		if (!player.movingVertically)	{		// don't want to set these if jumping, or we lose the speed of the conveyor				short tile = DarwinOnConveyor(player.theRect.left, player.theRect.top);			player.gOnLeftConveyor = (tile & maskConveyorLeft) >> 3;		player.gOnRightConveyor = (tile & maskConveyorRight) >> 4;	}		// which way is he facing ?		if (player.speedh < 0) player.directionFacing = directionLeft;	else if (player.speedh > 0) player.directionFacing = directionRight;		// get this out of the way first	if (player.dying)	{		DarwinDying();		return;	}		// only use the running frames if Darwin is moving		if (running && (player.speedh == 0)) running = false;	if (!running && (player.gDarwinStamina < 171))	{		player.gDarwinStamina += 0.1;		DrawStaminaBar();	}	SetRect(&testRect, player.theRect.left + 16, player.theRect.top, player.theRect.left + 48, player.theRect.bottom);	if (player.powerUp & jetPack)		HandleJetPack();	else if (player.gThrowingBanana)	ThrowBanana();	// handle the throwing of the banana	else if (player.movingVertically)	MoveDarwinVertical();	else if (TestMoveSpriteDown(&testRect, 1, &dummy) == 0) SetupDarwinFalling();	else if (player.darwinTired)		MoveDarwinHoriz(); // can't do anything else	else 	{		if (throwing) SetupThrowBanana();	// player wants to throw a banana; not jumping or falling, so no reason why not		else if (jumping) SetupJumping();			else if (((movingLeft + movingRight + running + throwing + jumping) == 0)									&& (player.speedh == 0) && (player.gLanding == 0))	DarwinIdle();		else MoveDarwinHoriz();	}}void	HandleJetPack(void){	short	ignore;	short	temp2;	Rect	testRect;	short	temp = player.theRect.top;	SetRect(&testRect, player.theRect.left + 16, player.theRect.top, player.theRect.left + 48, player.theRect.bottom);	player.iconRow = jumpRow;	player.gOnRightConveyor = false;	player.gOnLeftConveyor = false;	player.heightFallen = 0;		UpdateHorizontalPosition(player.speedh);	if (jumping)	{		// player wants to thrust up				if (player.speedv > -5) player.speedv--;	}	else if (player.speedv < 3) player.speedv++;	// handle vertical movement, but don't allow the player to actually land on a platform	if (player.speedv < 0)	{		temp2 = TestMoveSpriteUp(&testRect, (short)(0 - player.speedv));				if ((temp2 + (short)player.speedv) == 0) player.theRect.top -= temp2; // not blocked this time		else		{			player.theRect.top -= temp2; // might be zero, but might not			player.speedv = 0;		}	}	else if (player.speedv > 0)	{		short pixels = player.speedv;		ignore = TestMoveSpriteDown(&testRect, pixels + 2, &temp2);				// can fall "pixels" up to a maximum of temp2 - 2				if ((temp2 - 2) < pixels)		{			player.theRect.top += temp2 - 2;		}		else		{			player.theRect.top += pixels; // can fall all the way		}	}	scrollOffsetV += (player.theRect.top - temp);	player.theRect.bottom = player.theRect.top + darwinHeight;		// sort out animation	player.frame -= 11;	// 0 to 2	player.frame = (((++player.frame) % 3) + 11);}void	DarwinIdle( void ){	if (player.gOnRightConveyor) UpdateHorizontalPosition(conveyorSpeed);	else if (player.gOnLeftConveyor) UpdateHorizontalPosition(-conveyorSpeed);	if (player.framesInactive == 0) player.frame = 12;	// first idle frame	player.framesInactive++;	if (player.gDarwinStamina < 171)	{		player.gDarwinStamina += 0.1;		DrawStaminaBar();	}		if (player.framesInactive == 150) PlayASound(sndDarwinScratch);	if (player.framesInactive > 149)	{		// more that 5 seconds, so scratch				player.frame = (player.framesInactive - 150) >> 1;				player.iconRow = scratchRow;				if (player.framesInactive == 181)		{			player.framesInactive = 1;			player.iconRow = idleRow;			player.frame =  12;		}	}	else	{		// just breathing						if (frameCount & 1)		{			player.frame = player.frame % 12;			player.frame = (((++player.frame) % 10) + 12);		}		player.iconRow = idleRow;	}}/********************************************************//*														*//*				handle horizontal movement				*//*														*//********************************************************/void MoveDarwinHoriz ( void ){	if (player.gOnRightConveyor) UpdateHorizontalPosition(conveyorSpeed);	else if (player.gOnLeftConveyor) UpdateHorizontalPosition(-conveyorSpeed);	if (player.gLanding)	{		if (player.frame > 10)		{			player.frame = 0;			player.iconRow = walkRow;			player.gJumpingFrames = false;			player.movingVertically = false;			player.gLanding = false;		}				if (player.frame == 10)	// changed from 15		{			player.gLanding = false;			player.frame = 0;			player.iconRow = walkRow;		}		else ++player.frame;	}	else	{		if (player.darwinTired)		{			player.iconRow = tiredRow;						if (frameCount & 2)			{				player.frame = (++player.frame) % 16;				if (player.frame == 0) PlayASound(sndDarwinTired);			}			player.gDarwinStamina += 0.2;			DrawStaminaBar();			if (player.gDarwinStamina > 20) player.darwinTired = false;				}		else		{			if (running)	player.iconRow = runningRow;			else player.iconRow = walkRow;			if (player.speedh != 0)			{				if (running)				{					player.frame = (++player.frame) % 12;					if ((player.frame == 0) || (player.frame == 6)) PlayASound(sndDarwinRun);				}				else				{					player.frame = (++player.frame) % 22;					if ((player.frame == 9) || (player.frame == 20)) PlayASound(sndDarwinWalk);				}			}			else			{				player.frame = 0;				if (player.gDarwinStamina < 171)				{					player.gDarwinStamina += 0.1;					DrawStaminaBar();				}			}		}	}	if (!(player.darwinTired)) UpdateHorizontalPosition(player.speedh);		player.framesInactive = 0;}void SetupJumping(void){	Rect	tempRect;	// player wants to jump, so check there is nothing above, and set the jump direction	// to the present facing direction	SetRect(&tempRect, player.theRect.left + 16, player.theRect.top, player.theRect.left + 48, player.theRect.bottom);	if (TestMoveSpriteUp(&tempRect, 12) != 0)	{		player.speedv = -12;	// moving up 12 pixels per frame		player.iconRow = jumpRow;		player.frame = 0;		player.gJumpingFrames = true;		player.movingVertically = true;		PlayASound(sndDarwinJump);		MoveDarwinVertical();	}	else MoveDarwinHoriz();		player.framesInactive = 0;}/********************************************************//*														*//*		handle jumping and falling						*//*														*//********************************************************/void MoveDarwinVertical(void){	short temp;			temp = player.theRect.top;	// add control to the jump	player.iconRow = jumpRow;	if (player.frame < 8) player.frame++;	else	{		// if he is at the top of the jump, move to frame 19				if ((player.speedv > -0.4) && (player.speedv < 0.4))			if (player.frame < 10) player.frame++;		}	/* horizontal movement - same direction until hits something */		// only if past frame 5		// conveyors are speed 3/2 - only if jumping	if (player.gOnRightConveyor) UpdateHorizontalPosition(conveyorSpeed);	else if (player.gOnLeftConveyor) UpdateHorizontalPosition(-conveyorSpeed);	if (player.frame > 5) UpdateHorizontalPosition(player.speedh);		// not inactive		player.framesInactive = 0;		// if jumping, but not yet at the right frame, don't move up		if (player.movingVertically && (player.frame < 6)) return;		/* check if moving up or down */		if (player.speedv < 0)	{		short	temp2;		Rect	tempRect;				SetRect(&tempRect, player.theRect.left + 16, player.theRect.top, player.theRect.left + 48, player.theRect.bottom);				temp2 = TestMoveSpriteUp(&tempRect, (short)(0 - player.speedv));				if ((temp2 + (short)player.speedv) == 0) player.theRect.top -= temp2; // not blocked this time		else		{			player.theRect.top -= temp2; // might be zero, but might not			player.speedv = -player.speedv;			scrollOffsetV += (player.theRect.top - temp);			player.theRect.bottom = player.theRect.top + darwinHeight;			return;		}	}	else	// sprite is descending, so need to check if landed on anything	{		short blocked;		short pixels = player.speedv;		short temp2;		Rect	testRect;				SetRect(&testRect, player.theRect.left + 16, player.theRect.top, player.theRect.left + 48, player.theRect.bottom);		blocked = TestMoveSpriteDown(&testRect, pixels, &temp2);				if (!blocked)		{			player.theRect.top += pixels; // can fall all the way			player.heightFallen += pixels;			if (player.powerUp & beanieHat)			{				player.frame = 14 + (frameCount & 1);				player.iconRow = jumpRow;				player.heightFallen = 0;			}		}		else		{			player.theRect.top += temp2;			player.heightFallen += temp2;						if (player.powerUp & beanieHat)			{				// switch back to first walking frame							player.frame = 0;				player.iconRow = walkRow;				player.gJumpingFrames = false;				player.movingVertically = false;			}			else			{				if (player.gJumpingFrames)	player.gLanding = true;				player.gJumpingFrames = false;				player.movingVertically = false;				// adjust energy based on height fallen				if ((player.heightFallen > 175) && !(blocked & 128))				{					player.gDarwinLife -= (player.heightFallen - 175)/2;					if (player.heightFallen > 225) player.gDarwinLife -= (player.heightFallen - 225);					DrawLifeBar();								#ifndef DEMO						if (invincible)					{						if (player.gDarwinLife < 1) player.gDarwinLife = 1;						PlayASound(sndDarwinLand);					}					else if (player.gDarwinLife < 1)					{						SetupDeath();						player.gDarwinLife = 0;						PlayASound(sndDarwinDieFall);					}					else PlayASound(sndDarwinDamageFall);				#else					if (player.gDarwinLife < 1)					{						SetupDeath();						player.gDarwinLife = 0;						PlayASound(sndDarwinDieFall);					}					else PlayASound(sndDarwinDamageFall);				#endif				}				else PlayASound(sndDarwinLand);			}						player.speedv = 0;			player.heightFallen = 0;						scrollOffsetV += (player.theRect.top - temp);			player.theRect.bottom = player.theRect.top + darwinHeight;			return;		}	}	// gravity sucks	scrollOffsetV += (player.theRect.top - temp);	player.theRect.bottom = player.theRect.top + darwinHeight;		if (player.powerUp & beanieHat)	{		if (player.speedv > 0)		{			if (player.speedv < 3) player.speedv += accelV; // terminal velocity - 2 pixels			else player.speedv = 3;		}		else player.speedv += accelV; // terminal velocity - 18 pixels	}	else if (player.speedv < 18) player.speedv += accelV; // terminal velocity - 18 pixels}void	SetupDarwinFalling(void){	player.movingVertically = true;	player.heightFallen = 0;	player.speedh = 0;	player.speedv = 1;	player.gOnRightConveyor = false;	player.gOnLeftConveyor = false;	player.gLanding = false;	if (player.gThrowingBanana)	{		player.gThrowingBanana = false;		player.delayToNextThrow = 4;	}		player.frame = 10; // frame 10 of jumping	player.gJumpingFrames = true;	player.iconRow = jumpRow;	player.framesInactive = 0;}// throw a bananavoid	SetupThrowBanana(void){	// can't start to throw a banana if already throwing one, or jumping or falling	if (player.gThrowingBanana) return;	if (player.movingVertically) return;	if (player.delayToNextThrow) return;	// threw one too recently	player.gThrowingBanana = true;	player.gLanding = false;		player.speedh = 0;		player.iconRow = throwRow;		player.frame = 0;	player.framesInactive = 0;}void	ThrowBanana(void){	Rect tempRect;		// while throwing can't do anything else	if (player.gOnRightConveyor) UpdateHorizontalPosition(conveyorSpeed);	else if (player.gOnLeftConveyor) UpdateHorizontalPosition(-conveyorSpeed);	if (player.frame++ == 11)	{		// can only create a banana if he could move in the appropriate direction				if (player.powerUp & multipleFire) CreateBananas(&player);		else		{			if (player.directionFacing == directionLeft)			{				SetRect(&tempRect, player.theRect.left + 16, player.theRect.top + 5, player.theRect.left + 48, player.theRect.bottom);				if (TestMoveSpriteLeft(&tempRect, 24) == 24)				{					SetRect(&tempRect, player.theRect.left - 8, player.theRect.top,									player.theRect.left + 16, player.theRect.top + 24);					if (TestMoveSpriteLeft(&tempRect, 12) == 12)					{						AllocateBanana(&tempRect, -12, 0);						PlayASound(sndDarwinThrow);						player.numberOfBananas--;						DrawKeyBananaStatus();					}							}			}			else			{				SetRect(&tempRect, player.theRect.left + 16, player.theRect.top + 5, player.theRect.left + 48, player.theRect.bottom);				if (TestMoveSpriteRight(&tempRect, 24) == 24)				{					SetRect(&tempRect, player.theRect.left + 48, player.theRect.top,									player.theRect.left + 72, player.theRect.top + 24);												if (TestMoveSpriteRight(&tempRect, 12) == 12)					{						AllocateBanana(&tempRect, 12, 0);						PlayASound(sndDarwinThrow);						player.numberOfBananas--;						DrawKeyBananaStatus();					}							}			}		}				player.gThrowingBanana = false;				if (player.powerUp & fastFire) player.delayToNextThrow = 0;		else player.delayToNextThrow = 8;		player.frame = 0;		player.iconRow = walkRow;	}	player.framesInactive = 0;}// create 5 bananas moving in different directionsvoid	CreateBananas(PlayerSpritePtr playerPtr){	// need to set the rects based on the player rect, then check that each one can	// move in the appropriate direction	Rect		tempRect;	Boolean		allocated = false;		// first right		SetRect(&tempRect, player.theRect.left + 16, player.theRect.top + 5, player.theRect.left + 48, player.theRect.bottom);	if (TestMoveSpriteRight(&tempRect, 24) == 24)	{		SetRect(&tempRect, playerPtr->theRect.left + 48, playerPtr->theRect.top,						playerPtr->theRect.left + 72, playerPtr->theRect.top + 24);				if (TestMoveSpriteRight(&tempRect, 12))		{			AllocateBanana(&tempRect, 12, 0);					if (TestMoveSpriteUp(&tempRect, 8)) AllocateBanana(&tempRect, 8, -8);			allocated = true;				}	}		// then left	SetRect(&tempRect, player.theRect.left + 16, player.theRect.top + 5, player.theRect.left + 48, player.theRect.bottom);	if (TestMoveSpriteLeft(&tempRect, 24) == 24)	{		SetRect(&tempRect, playerPtr->theRect.left - 8, playerPtr->theRect.top,						playerPtr->theRect.left + 16, playerPtr->theRect.top + 24);		if (TestMoveSpriteLeft(&tempRect, 12))		{			AllocateBanana(&tempRect, -12, 0);			if (TestMoveSpriteUp(&tempRect, 8)) AllocateBanana(&tempRect, -8, -8);			allocated = true;		}	}		// finally up	SetRect(&tempRect, player.theRect.left + 16, player.theRect.top + 5, player.theRect.left + 48, player.theRect.bottom);	if (TestMoveSpriteUp(&player.theRect, 24) == 24)	{		SetRect(&tempRect, playerPtr->theRect.left + 20, playerPtr->theRect.top - 24,						playerPtr->theRect.left + 44, playerPtr->theRect.top);		if (TestMoveSpriteUp(&tempRect, 24) == 24)		{			AllocateBanana(&tempRect, 0, -12);			allocated = true;				}	}		if (allocated)	{		player.numberOfBananas--;		PlayASound(sndDarwinThrow);		DrawKeyBananaStatus();	}}void	AllocateBanana(Rect *theRect, short speedh, short speedv){	BananaSpritePtr	theBanana, tempBanana;	theBanana = (BananaSpritePtr)NewPtrClear(sizeof(BananaSprite));	if (theBanana == nil) FatalError("Sprite Allocation Failed", true);	if (firstBanana == nil)	{		firstBanana = theBanana;	}	else	{		// now find the last one in the list		tempBanana = firstBanana;				while (tempBanana->nextSprite != nil) tempBanana = tempBanana->nextSprite;				tempBanana->nextSprite = theBanana;		theBanana->prevSprite = tempBanana;	}		theBanana->kind = maskBanana;	theBanana->frame = 0;	theBanana->needToDraw = true;		theBanana->room = theGlobals.theRoom;	// only sprites in the current room are handled	theBanana->speedh = speedh;	theBanana->theRect.left = theRect->left;	theBanana->theRect.top = theRect->top;	theBanana->speedv = speedv;	theBanana->theRect.right = theBanana->theRect.left + 24;	theBanana->theRect.bottom = theBanana->theRect.top + 24;	// need to set the address for blitting	theBanana->source = (short *)theGWorlds.bananaMemPtr;	theBanana->sourceRowBytes = theGWorlds.darwinRowOffSet;}void	SetupDeath(void){	player.dying = true;			// set the frame to the first death frame		player.frame = 0;	player.iconRow = deathRow;	//12 * tileSize; //newchanged	DarwinDying();	// now run the first dying frame}void	DarwinDying(){	if (!(frameCount & 1))	{		player.frame++;				if (player.frame == 17)		{			player.gDead = true;			player.dying = false;		}	}	player.framesInactive = 0;}void	HandleTeleport(void){	// frames 12 to 21 are used for teleport	//playerData.teleportDirection = 1;	// move left	//playerData.teleportDirection = 2;	// move right	if (player.teleporting == 1)	{		// teleporting out		player.iconRow = teleportRow;		player.frame++;				if (player.frame == 21)		{			player.enteredDoor = 0 - player.enteredDoor;		}	}	else if (player.teleporting == 2)	{		// teleporting in				player.iconRow = teleportRow;		--player.frame;		if (player.frame == 12)		{			player.teleporting = 0; // done						if (player.teleportDirection == 1) player.speedh = -5;			else player.speedh = 5;		}	}	else if (player.teleporting == 3)	{		// time machine out		player.iconRow = timeMachineRow;		if (frameCount & 1) player.frame++;				if (player.frame == 21)	player.enteredDoor = 0 - player.enteredDoor; // allow door animation to run	}	else if (player.teleporting == 4)	{		// time machine in			player.iconRow = timeMachineRow;		if (player.door->frame == 5) player.frame = 6;		else if (player.door->frame > 5) player.frame = 14;		else if (frameCount & 1) player.frame--;		if (player.frame == 0)		{			player.teleporting = 0; // done						if (player.teleportDirection == 1) player.speedh = -5;			else player.speedh = 5;		}	}}void	UpdateHorizontalPosition(float offset){	Rect	tempRect;	SetRect(&tempRect, player.theRect.left + 16, player.theRect.top + 5, player.theRect.left + 48, player.theRect.bottom);	if (offset < 0) player.posh -= TestMoveSpriteLeft(&tempRect, (short)(0 - offset));	else if (offset > 0) player.posh += TestMoveSpriteRight(&tempRect, (short)offset);	player.theRect.left = player.posh;	player.theRect.right = player.theRect.left + darwinWidth;}short DarwinOnConveyor(short h, short v){	short hmod1, hmod2, hmod3, vmod;	hmod1 = (h + 11)/24;	hmod2 = (h + 53)/24;	hmod3 = (h + 36)/24;	vmod = (v/24) + 3;	return (GetPlatformDataType(hmod1,vmod) | GetPlatformDataType(hmod2,vmod) | GetPlatformDataType(hmod3,vmod));}