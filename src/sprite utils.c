#include "globals extern.h"#include	<ctype.h>short vmod, hmod1, hmod2, hmod3;/* routines to check if sprite is allowed to move in a particular direction */short	TestMoveSpriteLeft(Rect *theSpriteRect, short pixels){	short horiz, vertMin, vertMax, value, i;	short returnValue = pixels;	// test if sprite is going to move through a grid array		// if not it can move the required number of pixels	//	if ((theSpriteRect->left % 24) == ((theSpriteRect->left - pixels) % 24))	if ((theSpriteRect->left/24) == ((theSpriteRect->left - pixels)/24))	{		// don't need to do anything else	}	else	{		// will go through a grid array, so check the next array					horiz = (theSpriteRect->left/24) - 1;		vertMin = theSpriteRect->top/24;		vertMax = (theSpriteRect->bottom - 1)/24; // check				value = 0;				for (i = vertMin; i <= vertMax; i++)		{			value = value | GetPlatformDataType(horiz, i);				}				if (value & 2)		{			returnValue = theSpriteRect->left % 24; // move to grid limit		}		// otherwise can move the whole stretch	}	if (returnValue > pixels) returnValue = pixels;	if (theSpriteRect->left < 24)	{		// might move outside playing area				if (returnValue > theSpriteRect->left) returnValue = theSpriteRect->left;	}			return returnValue;}short	TestSpriteWalkOffPlatformLeft(Rect *theSpriteRect, short pixels){	Rect	tempRect;	short	value;	short returnValue = pixels;	// test if sprite is going to move through a grid array		tempRect.left = theSpriteRect->left;	tempRect.right = theSpriteRect->right;	tempRect.top = theSpriteRect->bottom;	tempRect.bottom = theSpriteRect->bottom + 24;		// if not it can move the required number of pixels		if ((tempRect.left/24) == ((tempRect.left - pixels)/24))	{		// don't need to do anything else				return pixels;	}	else	{		// will go through a grid array, so check the next array						value = GetPlatformDataType(((tempRect.left/24) - 1), (tempRect.top/24));				if (value & 2)	// can move the whole stretch		{			returnValue = pixels;		}		else returnValue = tempRect.left % 24; // move to grid limit		}	return returnValue;}short	TestMoveSpriteRight(Rect *theSpriteRect, short pixels){	short horiz, vertMin, vertMax, value, i;	short returnValue = pixels;	// test if sprite is going to move through a grid array		// if not it can move the required number of pixels		if (((theSpriteRect->right - 1)/24) == ((theSpriteRect->right + pixels)/24))	{		// don't need to do anything else	}	else	{		// will go through a grid array, so check the next array					horiz = ((theSpriteRect->right - 1)/24) + 1;		vertMin = theSpriteRect->top/24;		vertMax = (theSpriteRect->bottom - 1)/24; // check				value = 0;				for (i = vertMin; i <= vertMax; i++)		{			value = value | GetPlatformDataType(horiz, i);				}				if (value & 2)		{			returnValue = 23 - (theSpriteRect->right % 24); // move to grid limit		}		// otherwise can move the whole stretch	}		if (returnValue > pixels) returnValue = pixels;		if ((roomWidthPixels - theSpriteRect->right) < 24)	{		if (returnValue > (roomWidthPixels - theSpriteRect->right)) returnValue = (roomWidthPixels - theSpriteRect->right);		}		return returnValue;}#ifndef DEMOvoid CheckRegistrationTwo( void ){	long		nameNumber, regcode;	Str255		nameText;	short t,tt;	long		temp;	int worldswitch[2][8] = {	   							1,4,5,11,18,21,24,27,	   							2,3,8,14,17,23,27,29	   						};   		// need to check for blacklisted registration codes	if (((**gPrefs).registerName[0] < 1) || ((**gPrefs).registerName[1] == ' '))	{		// invalid string					CopyString((**gPrefs).registerName, "\pYour name");			(**gPrefs).registrationCode = 0;			gRegistered = 0;			// write out the modified preferences to disk									UpdatePreferences();			return;	}	else if ((**gPrefs).registerName[0] > 31) (**gPrefs).registerName[0] = 31;	 	StringToNum((**gPrefs).registerName, &nameNumber);	CopyString(nameText, (**gPrefs).registerName);	nameNumber &= 0x7FFFFFFF;	regcode = (**serialNumberHandle).serialNumber + nameNumber;	for(t = 1;t <= nameText[0];t++)	/************* do bitswitch for name *************/	{		if (nameText[t] == 0) goto pushon;		nameText[t] = tolower(nameText[t]);		if (nameText[t] == 32) nameText[t] = 128;		temp = nameText[t]-97;		if (BitTst(&regcode,temp)) BitClr(&regcode,temp);		else BitSet(&regcode,temp);	}	 	pushon:	 		for(tt=0;tt<8;tt++) 	{			   		if (BitTst(&regcode,worldswitch[1][tt])) BitClr(&regcode,worldswitch[1][tt]);		else BitSet(&regcode,worldswitch[1][tt]);	}	regcode &= 0x7FFFFFFF;	if ((**gPrefs).registrationCode == regcode) gRegistered = 135;	else 	{		CopyString((**gPrefs).registerName, "\pYour name");		(**gPrefs).registrationCode = 0;		gRegistered = 0;		// write out the modified preferences to disk							UpdatePreferences();	}}#endifshort	TestSpriteWalkOffPlatformRight(Rect *theSpriteRect, short pixels){	Rect	tempRect;	short	value;	short returnValue = pixels;	// test if sprite is going to move through a grid array		tempRect.left = theSpriteRect->left;	tempRect.right = theSpriteRect->right;	tempRect.top = theSpriteRect->bottom;	tempRect.bottom = theSpriteRect->bottom + 24;		// if not it can move the required number of pixels		if (((tempRect.right - 1)/24) == ((tempRect.right + pixels)/24))	{		// don't need to do anything else				return pixels;	}	else	{		// will go through a grid array, so check the next array						value = GetPlatformDataType(((tempRect.right - 1)/24) + 1, (tempRect.top/24));				if (value & 2)	// can move the whole stretch		{			returnValue = pixels;		}		else returnValue = 23 - (tempRect.right % 24); // move to grid limit		}	return returnValue;}#ifdef DEMOvoid	WorldCheckFour(short	whichRoom){	if (whichRoom == 0)	{		if (roomHeightTiles != 75) hackedFour = true;	}	else if (whichRoom == 1)	{		if (roomHeightTiles != 114) hackedFour = true;	}	else if (whichRoom == 2)	{		if (roomHeightTiles != 174) hackedFour = true;	}	else hackedFour = true;}#endifshort	TestMoveSpriteDown(Rect *theSpriteRect, short pixels, short *returnValue){	short vert, horizMin, horizMax, value, i;	*returnValue = pixels;	// test if sprite is going to move through a grid array		// if not it can move the required number of pixels		if (((theSpriteRect->bottom - 1)/24) == (((theSpriteRect->bottom - 1) + pixels)/24))	{		// don't need to do anything else				value = 0;	}	else if ((theSpriteRect->bottom % 24) == 0)	{		// actually on a grid line				vert = theSpriteRect->bottom/24;		horizMin = theSpriteRect->left/24;		horizMax = (theSpriteRect->right - 1)/24;				value = 0;				for (i = horizMin; i <= horizMax; i++) value = value | GetPlatformDataType(i, vert);				if (value) *returnValue = 0; //  since on a grid point				// otherwise can move the whole stretch	}	else	{		// will go through a grid array, so check the next array					vert = ((theSpriteRect->bottom - 1)/24) + 1;		horizMin = theSpriteRect->left/24;		horizMax = (theSpriteRect->right - 1)/24;				value = 0;				for (i = horizMin; i <= horizMax; i++) value = value | GetPlatformDataType(i, vert);				if (value) *returnValue = 24 - (theSpriteRect->bottom % 24); // move to grid limit				// otherwise can move the whole stretch	}		if (*returnValue > pixels) *returnValue = pixels;		if ((roomHeightPixels - theSpriteRect->bottom) < 24)	{		if (*returnValue > (roomHeightPixels - theSpriteRect->bottom)) *returnValue = (roomHeightPixels - theSpriteRect->bottom);		}		return value;}/* routines to check if sprite is allowed to move in a particular direction */short	TestMoveSpriteUp(Rect *theSpriteRect, short pixels){	short vert, horizMin, horizMax, value, i;	short returnValue = pixels;	// test if sprite is going to move through a grid array		// if not it can move the required number of pixels		if ((theSpriteRect->top/24) == ((theSpriteRect->top - pixels)/24))	{		// don't need to do anything else	}	else	{		// will go through a grid array, so check the next array					vert = (theSpriteRect->top/24) - 1;		horizMin = theSpriteRect->left/24;		horizMax = (theSpriteRect->right - 1)/24;				value = 0;				for (i = horizMin; i <= horizMax; i++)		{			value = value | GetPlatformDataType(i, vert);				}				if (value & 2)		{			returnValue = theSpriteRect->top % 24; // move to grid limit		}		// otherwise can move the whole stretch	}		if (returnValue > pixels) returnValue = pixels;		if (theSpriteRect->top < 24)	{		if (returnValue > theSpriteRect->top) returnValue = theSpriteRect->top;	}		return returnValue;}