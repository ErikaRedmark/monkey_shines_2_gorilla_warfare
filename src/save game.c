#include "globals extern.h"void SaveGame(void){	StandardFileReply	theReply;	short				saveFile, oldFile;		ISpSuspend();	CustomShowCursor();	FlushEvents(everyEvent, 0);	oldFile = CurResFile();	StandardPutFile("\pSaved Game Name", "\pGorilla Warfare Saved Game", &theReply);	if (theReply.sfGood)	{		if (!theReply.sfReplacing) FSpCreateResFile(&theReply.sfFile, 'bNz2', 'gWsV', smSystemScript);				saveFile = FSpOpenResFile(&theReply.sfFile, fsRdWrPerm);		UseResFile(saveFile);		// TODO error handling				if (theReply.sfReplacing)		{			Handle	tempHandle;					// remove the resources first.			// FiLe 2000			// pLyR 2000			// sCoR 2000			// mNsT 2000			// dOrS 2000			// iTeM 2000			// TsMn	2000			tempHandle = Get1Resource('FiLe', 2000);			RemoveResource(tempHandle);			UpdateResFile(saveFile);			tempHandle = Get1Resource('pLyR', 2000);			RemoveResource(tempHandle);			UpdateResFile(saveFile);			tempHandle = Get1Resource('sCoR', 2000);			RemoveResource(tempHandle);			UpdateResFile(saveFile);			tempHandle = Get1Resource('mNsT', 2000);			RemoveResource(tempHandle);			UpdateResFile(saveFile);						tempHandle = Get1Resource('dOrS', 2000);			RemoveResource(tempHandle);			UpdateResFile(saveFile);						tempHandle = Get1Resource('iTeM', 2000);			RemoveResource(tempHandle);			UpdateResFile(saveFile);			tempHandle = Get1Resource('TsMn', 2000);			RemoveResource(tempHandle);			UpdateResFile(saveFile);		}				SaveFileSpec();		SavePlayer();		SaveMonsters();		SaveDoors();		SaveItems();		SaveTalisman();				CloseResFile(saveFile);	}	justSaved = true;	UseResFile(oldFile);	SetCCursor(theUserInterface.myCursor);	CustomHideCursor();	ISpResume();}void SaveFileSpec(void){	FSSpec **tempSpec = (FSSpec **)NewHandle(sizeof(FSSpec));	if (tempSpec == nil) FatalError("Save file allocation failed", true);	BlockMoveData(&theFileStuff.worldFileSpec, *tempSpec, sizeof(FSSpec));	AddResource((Handle)tempSpec, 'FiLe', 2000, nil);	ReleaseResource((Handle)tempSpec);}void SavePlayer(void){	PlayerSprite	**tempPlayer;	GameGlobals		**theGlobalsHandle;		tempPlayer = (PlayerSpritePtr *)NewHandle(sizeof(PlayerSprite));	if (tempPlayer == nil) FatalError("Error saving game", true);	BlockMoveData(&player, *tempPlayer, sizeof(PlayerSprite));	AddResource((Handle)tempPlayer, 'pLyR', 2000, nil);	ReleaseResource((Handle)tempPlayer);			theGlobalsHandle = (GameGlobals **)NewHandle(sizeof(GameGlobals));	if (theGlobalsHandle == nil) FatalError("Error saving game", true);	(*theGlobalsHandle)->gScore = theGlobals.gScore;	(*theGlobalsHandle)->gLivesLeft = theGlobals.gLivesLeft;	(*theGlobalsHandle)->theRoom = theGlobals.theRoom;	(*theGlobalsHandle)->difficulty = theGlobals.difficulty;	(*theGlobalsHandle)->worldsCompleted = theGlobals.worldsCompleted;		AddResource((Handle)theGlobalsHandle, 'sCoR', 2000, nil);	ReleaseResource((Handle)theGlobalsHandle);}void SaveMonsters(void){	short				count;	Handle				tempHandle;	MonsterSpritePtr	tempMonster = firstMonster;		count = 0;	while (tempMonster != nil)	{		count++;		tempMonster = tempMonster->nextSprite;	}		if (count != 0)	{		// allocate enough memory to store all the sprites		tempHandle = NewHandleClear(count * sizeof(MonsterSprite));		if (tempHandle == nil) FatalError("Error saving game", true);		count = 0;		tempMonster = firstMonster;		while (tempMonster != nil)		{			BlockMoveData(tempMonster, *tempHandle + (count * sizeof(MonsterSprite)), sizeof(MonsterSprite));			tempMonster = tempMonster->nextSprite;			count++;		}				AddResource(tempHandle, 'mNsT', 2000, nil);		ReleaseResource(tempHandle);	}}void SaveDoors(void){	short				count;	Handle				tempHandle;	DoorSpritePtr		tempDoor = firstDoor;		count = 0;	while (tempDoor != nil)	{		count++;		tempDoor = tempDoor->nextSprite;	}		if (count != 0)	{		// allocate enough memory to store all the sprites		tempHandle = NewHandleClear(count * sizeof(DoorSprite));		if (tempHandle == nil) FatalError("Error saving game", true);		count = 0;		tempDoor = firstDoor;		while (tempDoor != nil)		{			BlockMoveData(tempDoor, *tempHandle + (count * sizeof(DoorSprite)), sizeof(DoorSprite));			tempDoor = tempDoor->nextSprite;			count++;		}				AddResource(tempHandle, 'dOrS', 2000, nil);		ReleaseResource(tempHandle);	}}void SaveItems(void){	short				count;	Handle				tempHandle;	ItemSpritePtr		tempItem = firstItem;		count = 0;	while (tempItem != nil)	{		count++;		tempItem = tempItem->nextSprite;	}		if (count != 0)	{		// allocate enough memory to store all the sprites		tempHandle = NewHandleClear(count * sizeof(ItemSprite));		if (tempHandle == nil) FatalError("Error saving game", true);		count = 0;		tempItem = firstItem;		while (tempItem != nil)		{			BlockMoveData(tempItem, *tempHandle + (count * sizeof(ItemSprite)), sizeof(ItemSprite));			tempItem = tempItem->nextSprite;			count++;		}				AddResource(tempHandle, 'iTeM', 2000, nil);		ReleaseResource(tempHandle);	}}void SaveTalisman(void){	short				count;	Handle				tempHandle;	TalismanSpritePtr	tempTalisman = firstTalisman;		count = 0;	while (tempTalisman != nil)	{		count++;		tempTalisman = tempTalisman->nextSprite;	}		if (count != 0)	{		// allocate enough memory to store all the sprites		tempHandle = NewHandleClear(count * sizeof(ItemSprite));		if (tempHandle == nil) FatalError("Error saving game", true);		count = 0;		tempTalisman = firstTalisman;		while (tempTalisman != nil)		{			BlockMoveData(tempTalisman, *tempHandle + (count * sizeof(TalismanSprite)), sizeof(TalismanSprite));			tempTalisman = tempTalisman->nextSprite;			count++;		}				AddResource(tempHandle, 'TsMn', 2000, nil);		ReleaseResource(tempHandle);	}}void LoadGame(void){	short	wasResFile = CurResFile();		UseResFile(theFileStuff.saveResFile);	LoadPlayer();	LoadMonsters();	LoadDoors();	LoadItems();	LoadTalisman();		UseResFile(wasResFile);}void LoadFileSpec(void){	short	wasResFile;	FSSpec	**tempSpec;		wasResFile = CurResFile();	UseResFile(theFileStuff.saveResFile);		tempSpec = (FSSpec **)Get1Resource('FiLe', 2000);	if ((tempSpec == nil) || (ResError() != noErr))	FatalError("Error loading file specification", true);	BlockMoveData(*tempSpec, &theFileStuff.worldFileSpec, sizeof(FSSpec));	ReleaseResource((Handle)tempSpec);	UseResFile(wasResFile);}void LoadPlayer(void){	PlayerSprite	**tempPlayer;	GameGlobals		**theGlobalsHandle;		tempPlayer = (PlayerSprite **)Get1Resource('pLyR', 2000);	if ((tempPlayer == nil) || (ResError() != noErr))	FatalError("Saved Game Error - Player", true);	BlockMoveData(*tempPlayer, &player, sizeof(PlayerSprite));	ReleaseResource((Handle)tempPlayer);		player.sourceRowBytes = theGWorlds.darwinRowOffSet;		theGlobalsHandle = (GameGlobals **)Get1Resource('sCoR', 2000);	if ((theGlobalsHandle == nil) || (ResError() != noErr))	FatalError("Saved Game Error - Data", true);	theGlobals.gScore = (*theGlobalsHandle)->gScore;	theGlobals.gLivesLeft = (*theGlobalsHandle)->gLivesLeft;	theGlobals.theRoom = (*theGlobalsHandle)->theRoom;	theGlobals.difficulty = (*theGlobalsHandle)->difficulty;	theGlobals.worldsCompleted = (*theGlobalsHandle)->worldsCompleted;	ReleaseResource((Handle)theGlobalsHandle);}void LoadMonsters(void){	MonsterSpritePtr	tempSprite;	Handle	tempHandle;	short	i;		tempHandle = Get1Resource('mNsT', 2000);	if (tempHandle != nil)	{		short count2 = GetResourceSizeOnDisk(tempHandle) / sizeof(MonsterSprite);		for (i = 0; i < count2; i++)		{			// simply copy the data from the resource to the MonsterSprite						// don't copy all the data, or will overwrite the linked list						tempSprite = AllocateMonster();			BlockMoveData(*tempHandle + (i * sizeof(MonsterSprite)), tempSprite, sizeof(MonsterSpriteSave));			tempSprite->sourceRowBytes = (0x7FFF & (**theGWorlds.monsterPixMap[tempSprite->subKind]).rowBytes);	// only need to do this once		}		ReleaseResource(tempHandle);	}}void LoadDoors(void){	DoorSpritePtr	tempSprite;	Handle	tempHandle;	short	i;		tempHandle = Get1Resource('dOrS', 2000);	if (tempHandle != nil)	{		short count2 = GetResourceSizeOnDisk(tempHandle) / sizeof(DoorSprite);		for (i = 0; i < count2; i++)		{			// simply copy the data from the resource to the MonsterSprite			// don't copy all the data, or will overwrite the linked list			tempSprite = AllocateDoor();			BlockMoveData(*tempHandle + (i * sizeof(DoorSprite)), tempSprite, sizeof(DoorSpriteSave));			tempSprite->sourceRowBytes = (0x7FFF & (**theGWorlds.doorPixMap[tempSprite->subKind]).rowBytes);	// only need to do this once		}		ReleaseResource(tempHandle);	}	else FatalError("Saved Game Error - Doors", true);}void LoadItems(void){	Handle	tempHandle;	short	i;		tempHandle = Get1Resource('iTeM', 2000);	if (tempHandle != nil)	{		ItemSpritePtr	tempSprite;		short count2 = GetResourceSizeOnDisk(tempHandle) / sizeof(ItemSprite);		for (i = 0; i < count2; i++)		{			// simply copy the data from the resource to the MonsterSprite			// don't copy all the data, or will overwrite the linked list					tempSprite = AllocateItem();			BlockMoveData(*tempHandle + (i * sizeof(ItemSprite)), tempSprite, sizeof(ItemSpriteSave));			tempSprite->sourceRowBytes = theGWorlds.itemRowOffSet;		}		ReleaseResource(tempHandle);	}}void LoadTalisman(void){	Handle	tempHandle;	short	i;		tempHandle = Get1Resource('TsMn', 2000);	if (tempHandle != nil)	{		TalismanSpritePtr	tempSprite;		short count2 = GetResourceSizeOnDisk(tempHandle) / sizeof(TalismanSprite);		for (i = 0; i < count2; i++)		{			// simply copy the data from the resource to the MonsterSprite			// don't copy all the data, or will overwrite the linked list					tempSprite = AllocateTalisman();			BlockMoveData(*tempHandle + (i * sizeof(TalismanSprite)), tempSprite, sizeof(TalismanSpriteSave));			tempSprite->sourceRowBytes = theGWorlds.itemRowOffSet;		}		ReleaseResource(tempHandle);	}}