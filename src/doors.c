#include	"globals extern.h"extern	PlayerSprite			sparePlayer;				// sparePlayer used to remember where player came on screenvoid SetPlatformData(short i, short j, short whatItem);DoorSpritePtr AllocateDoor(void){	DoorSpritePtr	tempSprite, temp;		tempSprite = (DoorSpritePtr)NewPtrClear(sizeof(DoorSprite));	if (tempSprite == nil) FatalError("Sprite Allocation Failed", true);	if (firstDoor == nil)	{		firstDoor = tempSprite;	}	else	{		// now find the last one in the list		temp = firstDoor;		while (temp->nextSprite != nil) temp = temp->nextSprite;			temp->nextSprite = tempSprite;		tempSprite->prevSprite = temp;	}	return tempSprite;}DoorSpritePtr DisposeDoor(DoorSpritePtr theSprite){	DoorSpritePtr	returnValue;	DoorSpritePtr	tempSprite = theSprite;	if (theSprite == nil) FatalError("Trying to dispose of zero sprite", true);	returnValue = theSprite->nextSprite;		if (theSprite->nextSprite == nil)	// last door	{		if (theSprite == firstDoor) firstDoor = nil;	}	else if (theSprite == firstDoor)	{		firstDoor = theSprite->nextSprite;	}	if (tempSprite->nextSprite) (tempSprite->nextSprite)->prevSprite = tempSprite->prevSprite;	if (tempSprite->prevSprite) (tempSprite->prevSprite)->nextSprite = tempSprite->nextSprite;	DisposePtr( (Ptr)theSprite);	return returnValue;}void	HandleDoors(Rect *drawingRect){	DoorSpritePtr tempDoor = firstDoor;		while (tempDoor)	{		HandleOneDoor(tempDoor, drawingRect);		tempDoor = tempDoor->nextSprite;	}}void HandleOneDoor(DoorSpritePtr theDoor, Rect *drawingRect){	Rect	dummy;	short	width, i;	short	h, v, insetH, insetV;	short	centreDoor, centrePlayer;	theDoor->needToDraw = true;	if (theDoor->kind == maskDoorInactive) theDoor->needToDraw = false;	if (theDoor->room != theGlobals.theRoom) theDoor->needToDraw = false;		if (theDoor->needToDraw == false) return;		// may still need to handle it, even if we don't need to draw it				if (SectRect(drawingRect, &theDoor->theRect, &dummy)) theDoor->needToDraw = true;	else theDoor->needToDraw = false;		// if the door is opened by a key, need to do a bit more work	if (theDoor->subKind == 0)	{		//	the teleporter, more work needed			if (theDoor->frameDirection == -1)		{			if (frameCount & 1) theDoor->frame--;			if (theDoor->frame == 0) theDoor->frameDirection = 1;		}		else if (theDoor->doorNumber == 0)	// only the entry door		{			if (frameCount & 1) theDoor->frame++;			if (theDoor->frame == 16)			{				theDoor->kind = maskDoorInactive;				canAbort = true;				theDoor->needToDraw = false;			}		}		else if ((theDoor->doorNumber == 1000) && (player.teleporting == 3))		{			// Darwin is teleporting out			if (frameCount & 1) theDoor->frame++;			if (theDoor->frame == 16) theDoor->kind = maskDoorInactive;		}	}	else if (theDoor->subKind == 1)	{		if (theDoor->doorNumber == theDoor->doorDestination) theDoor->frame = theDoor->frames - 1;		else		{			theDoor->frame++;			if (theDoor->frame >= (theDoor->frames - 1)) theDoor->frame = 0;		}	}	else if (theDoor->subKind < 6)	{		if ((player.theRect.bottom <= theDoor->theRect.bottom) && (player.theRect.top >= theDoor->theRect.top))		{			// player is on the same level as the door						centreDoor = theDoor->theRect.left + 24;			centrePlayer = player.theRect.left + 32;									if (abs(centreDoor - centrePlayer) < 72)			{				if (player.key == (theDoor->subKind - 1))				{					// if player has the correct key, the door should open										if (theDoor->frame == 0) PlayASound(sndDoorOpens);					if (theDoor->frame < 7)	theDoor->frame++;				}			}			else if (theDoor->stayOpen == 0)			{				// the door should close whatever				if (theDoor->frame > 0) theDoor->frame--;			}		}		else		{			// the door should close						if (theDoor->frame > 0)			{				// door has at least started to open, so finish the job								if (theDoor->stayOpen != 0)				{					if (theDoor->frame < 7) theDoor->frame++;				}				else theDoor->frame--;			}		}				// either open or close the door				if (theDoor->frame == 7)		{								for (i = 0; i < 3; i++)			{				SetPlatformData(theDoor->hArray, theDoor->vArray + i, 0);									}		}		else if (theDoor->frame == 0)		{			for (i = 0; i < 3; i++)			{				SetPlatformData(theDoor->hArray, theDoor->vArray + i, 16);	// revert to blocking platform								}					}			}	else if (theDoor->subKind == 6)	{		Rect dummy2;				// save point				if (SectRect(&player.theRect, &theDoor->theRect, &dummy2))		{			// animate						theDoor->frame++;			if (theDoor->frame >= theDoor->frames) theDoor->frame = 0;						if (player.theRect.bottom == theDoor->theRect.bottom)			{				sparePlayer = player;				sparePlayer.speedh = 0;				sparePlayer.speedv = 0;				sparePlayer.movingVertically = false;	// just use speed.v ?				sparePlayer.gJumpingFrames = false;		// check iconRow ?				sparePlayer.frame = 0;				sparePlayer.iconRow = walkRow;								StoreKeyCopies();			}			else if (player.powerUp & (jetPack + beanieHat))			{				sparePlayer = player;				sparePlayer.speedh = 0;				sparePlayer.speedv = 0;				sparePlayer.movingVertically = false;	// just use speed.v ?				sparePlayer.gJumpingFrames = false;		// check iconRow ?				sparePlayer.frame = 0;				sparePlayer.iconRow = walkRow;								StoreKeyCopies();			}		}		else		{			if (theDoor->frame != 0) theDoor->frame--;		}	}	else	// door activated by a number of pieces of the talisman	{		if ((player.theRect.bottom <= theDoor->theRect.bottom) && (player.theRect.top >= theDoor->theRect.top))		{			// player is on the same level as the door						centreDoor = theDoor->theRect.left + 24;			centrePlayer = player.theRect.left + 32;						if (abs(centreDoor - centrePlayer) < 72)			{				if ((talismanBitField & theDoor->stayOpen) == theDoor->stayOpen)				{					// the door should open									if (theDoor->frame == 0) PlayASound(sndDoorOpens);					if (theDoor->frame < 7)	theDoor->frame++;				}			}			else			{				// the door should close whatever				if (theDoor->frame > 0) theDoor->frame--;			}		}		else		{			// the door should close						if (theDoor->frame > 0) theDoor->frame--;		}				// either open or close the door				if (theDoor->frame == 7)		{			for (i = 0; i < 3; i++)			{				SetPlatformData(theDoor->hArray, theDoor->vArray + i, 0);									}		}		else if (theDoor->frame == 0)		{			for (i = 0; i < 3; i++)			{				SetPlatformData(theDoor->hArray, theDoor->vArray + i, 16);	// revert to blocking platform								}					}	}		if (theDoor->needToDraw == false) return;			insetH = 0;	insetV = 0;	theDoor->drawingHeight = dummy.bottom - dummy.top;	theDoor->drawingWidth = dummy.right - dummy.left;		if (theDoor->drawingWidth != (theDoor->theRect.right - theDoor->theRect.left))	{		// need to clip horizontally			if (theDoor->theRect.left < drawingRect->left) insetH = drawingRect->left - theDoor->theRect.left;	}	if (theDoor->drawingHeight != (theDoor->theRect.bottom - theDoor->theRect.top))	{		// need to clip  vertically			if (theDoor->theRect.top < drawingRect->top) insetV = drawingRect->top - theDoor->theRect.top;	}	width = theDoor->theRect.right - theDoor->theRect.left;	h = theDoor->theRect.left - (24 * minActualHoriz);	v = theDoor->theRect.top - (24 * minActualVert);	theDoor->source = (short *)(theGWorlds.doorMemPtr[theDoor->subKind] + 2 * ((width * theDoor->frame) + insetH)										+ (insetV * theDoor->sourceRowBytes));	theDoor->dest = (short *)(theGWorlds.safeMemPtr + ((v + insetV) * theGWorlds.safeRowOffSet) + 2 * (h + insetH));}