#include	"globals extern.h"#include	<Displays.h>#include	<ROMDefs.h>#include	<Slots.h>#include	"gamma.h"#include	"resolution.h"GDHandle SelectMonitor( void ){	EventRecord	chooseScreenEvent;	short		screenCount;	GDHandle	tempGDHandle;	ScreenInfoPtr	currentScreen, lastScreen;	// get an event, and if option is pressed, user wants to choose the screen again		FlushEvents(everyEvent, 0);	WaitNextEvent(everyEvent, &chooseScreenEvent, 20L, nil);	// first count the number of active screens - no sense messing about if we only have one which is suitable	firstScreen = nil;	lastScreen = nil;	tempGDHandle = GetDeviceList();	do	{		if ((TestDeviceAttribute(tempGDHandle, screenDevice)))		{			if (TestDeviceAttribute(tempGDHandle, screenActive))			{				// the device is a screen, and is switched on, so check if it will support 640 x 480, 16 bit				currentScreen = (ScreenInfoPtr)NewPtrClear(sizeof(ScreenInfo));				if (firstScreen == nil)				{					firstScreen = currentScreen;					lastScreen = currentScreen;								}				else				{					lastScreen->nextScreen = currentScreen;	// link the list					lastScreen = currentScreen;				}								currentScreen->theGDevice = tempGDHandle;				currentScreen->theVideoRequest.screenDevice = tempGDHandle;		// chosen screen				currentScreen->theVideoRequest.reqBitDepth = 16;				// bit depth request				currentScreen->theVideoRequest.reqHorizontal = 640;				// H request				currentScreen->theVideoRequest.reqVertical = 480;				// V request				currentScreen->theVideoRequest.displayMode = nil;				// must init to nil				currentScreen->theVideoRequest.depthMode = nil;					// must init to nil				currentScreen->theVideoRequest.requestFlags = 1<<kBitDepthPriorityBit;	// give me the HxV over bit depth, and only safe video modes				// make the request and set it if we have one....				if (RVRequestVideoSetting(&(currentScreen->theVideoRequest)) == noErr)	currentScreen->screenOkay = true;				else currentScreen->screenOkay = false;			}						tempGDHandle = (GDHandle)(**tempGDHandle).gdNextGD;		}	} while (tempGDHandle);		// now we have a linked list of suitable screens		screenCount = 0;		currentScreen = firstScreen;		do {		if (currentScreen->screenOkay) screenCount++;		currentScreen = currentScreen->nextScreen;	} while (currentScreen);	// check if a screen has been previously chosen, and the user doesn't want to re-choose		if (((**gPrefs).prefsScreen != nil) && (!(chooseScreenEvent.modifiers & optionKey))				&& (!(chooseScreenEvent.modifiers & rightOptionKey)))	{		// loop through the screens to find the chosen one and make sure it is okay		currentScreen = firstScreen;		do {			if ((currentScreen->theGDevice == (**gPrefs).prefsScreen) && (currentScreen->screenOkay)) return (**gPrefs).prefsScreen;			else currentScreen = currentScreen->nextScreen;		} while (currentScreen);	}	// depending on the number of screens, a number of possibilities exist		if (screenCount == 1)	{		// only one screen, so loop through again and return the GDHandle						currentScreen = firstScreen;				do {			if (currentScreen->screenOkay) return currentScreen->theGDevice;	// return the graphics device			currentScreen = currentScreen->nextScreen;		} while (currentScreen);	}		(**gPrefs).prefsScreen = nil; // forget any choice	UpdatePreferences();		// if we get here, then either the user has not selected a screen, or the screen is not suitable	// or they want to choose again		tempGDHandle = UserSelectScreen(screenCount);		return tempGDHandle;}GDHandle UserSelectScreen(short screenCount){	Rect			bounds;	Rect			theRects[10], testRects[10];		// 10 should be more than will ever be required	Rect			tempRect, screenRect;	ScreenInfoPtr	currentScreen;	short			index, i, selectedScreen, checkBoxValue;	float			hRatio, vRatio;	WindowPtr		dialogWindow;	ControlHandle	dialogOkayButton, checkBox;	GDHandle		returnValue;	PicHandle		backPict, selectedPict, notSelectedPict;	currentScreen = firstScreen;	index = 0;		do {		if (currentScreen->screenOkay)		{			GDHandle tempGDHandle = currentScreen->theGDevice;					theRects[index] = (**tempGDHandle).gdRect;			index++;		}		currentScreen = currentScreen->nextScreen;	} while (currentScreen);		// got all the rects	bounds = theRects[0];		for (i = 1; i < screenCount; i++)	{		if (theRects[i].left < bounds.left) bounds.left = theRects[i].left;		if (theRects[i].top < bounds.top) bounds.top = theRects[i].top;		if (theRects[i].right > bounds.right) bounds.right = theRects[i].right;		if (theRects[i].bottom > bounds.bottom) bounds.bottom = theRects[i].bottom;	}		// now have a bounding rect for all the screens		hRatio = ((float)bounds.right - (float)bounds.left)/320;	vRatio = ((float)bounds.bottom - (float)bounds.top)/260;		if (hRatio < vRatio) hRatio = vRatio;	else vRatio = hRatio;		// now have a scaling factor to use	for (i = 0; i < screenCount; i++)	{		testRects[i].left = 20 + (theRects[i].left - bounds.left)/hRatio;		testRects[i].right = 20 + (theRects[i].right - bounds.left)/hRatio;		testRects[i].top = 40 + (theRects[i].top - bounds.top)/hRatio;		testRects[i].bottom = 40 + (theRects[i].bottom - bounds.top)/hRatio;	}	ForeColor(blackColor);	BackColor(whiteColor);	// load the pictures		backPict = GetPicture(131);	if (backPict == nil) FatalError("Error loading PICT 131 (resolution)", true);	selectedPict = GetPicture(132);	if (selectedPict == nil) FatalError("Error loading PICT 132 (resolution)", true);	notSelectedPict = GetPicture(133);	if (notSelectedPict == nil) FatalError("Error loading PICT 133 (resolution)", true);	// centre dialog on main screen		screenRect = ((**GetMainDevice()).gdRect);	tempRect.left = (screenRect.left + screenRect.right - 360)/2;	tempRect.right = tempRect.left + 360;	tempRect.top = (screenRect.top + screenRect.bottom - 360)/2;	tempRect.bottom = tempRect.top + 360;		// create the dialog window		dialogWindow  = NewCWindow(nil, &tempRect, "\p", true, plainDBox, (WindowPtr)-1L,							false, (long)nil);	SetGWorld((CWindowPtr)dialogWindow, GetMainDevice());	SetRect(&tempRect, 0, 0, 360, 360);	DrawPicture(backPict, &tempRect);	// which screen is selected first	selectedScreen = 0;	for (i = 0; i < screenCount; i++)	{				if (i == selectedScreen) DrawPicture(selectedPict, &testRects[i]);		else DrawPicture(notSelectedPict, &testRects[i]);	}		// load the buttons		SetRect(&tempRect, 280, 320, 340, 340); 	dialogOkayButton = NewControl( dialogWindow, &tempRect, "\pOkay", true, 0, 0, 0, 0, 0 );		SetRect(&tempRect, 20, 320, 220, 340); 	checkBox = NewControl( dialogWindow, &tempRect, "\pShow this dialog next time", true, 1, 0, 1, 1, 0 );	// dialog handling code	{				EventRecord dialogEvent;		short thePart;		WindowPtr whichWindow;		Point		mousePoint;		ControlHandle	dialogControl;		char theChar;		Boolean done = false;		while (!done)		{			if (WaitNextEvent(everyEvent, &dialogEvent, 20L, nil))			{				switch (dialogEvent.what)				{					case keyDown:						theChar = (dialogEvent.message & charCodeMask);						if (theChar == '\r')						{							done = true;						}						break;														case mouseDown:						thePart = FindWindow (dialogEvent.where, &whichWindow);						if (thePart == inContent)						{							mousePoint = dialogEvent.where;							GlobalToLocal(&mousePoint);							thePart = FindControl(mousePoint, whichWindow, &dialogControl);							if (dialogControl)							{								if (TrackControl(dialogControl, dialogEvent.where, nil))								{									if (dialogControl == dialogOkayButton) done = true;									else if (dialogControl == checkBox)									{										checkBoxValue = GetControlValue(checkBox);										checkBoxValue = !checkBoxValue;										SetControlValue(checkBox, checkBoxValue);									}								}							}							else							{								// handle clicks on screens															for (i = 0; i < screenCount; i++)								{									if (PtInRect(mousePoint, &testRects[i])) selectedScreen = i;								}																SetRect(&tempRect, 0, 0, 360, 360);								DrawPicture(backPict, &tempRect);																								for (i = 0; i < screenCount; i++)								{											if (i == selectedScreen) DrawPicture(selectedPict, &testRects[i]);									else DrawPicture(notSelectedPict, &testRects[i]);								}																DrawControls(dialogWindow);							}						}						break;					default:						break;				}			}		}	}			// flash the okay button	HiliteControl(dialogOkayButton, 10);	GWDelay(0, 10, false);	HiliteControl(dialogOkayButton, 0);	// if the user doesn't want the dialog showing next time, save the selected screen in	// the preferences	checkBoxValue = GetControlValue(checkBox);	DisposeWindow(dialogWindow);	ReleaseResource((Handle)backPict);	ReleaseResource((Handle)selectedPict);	ReleaseResource((Handle)notSelectedPict);	// now work out which screen was selected	currentScreen = firstScreen;	returnValue = nil;		do {		if (currentScreen->screenOkay)		{			GDHandle tempGDHandle = currentScreen->theGDevice;					if ((theRects[selectedScreen].left == (**tempGDHandle).gdRect.left) &&			(theRects[selectedScreen].right == (**tempGDHandle).gdRect.right) &&			(theRects[selectedScreen].top == (**tempGDHandle).gdRect.top) &&			(theRects[selectedScreen].bottom == (**tempGDHandle).gdRect.bottom))		 returnValue = tempGDHandle;		}		currentScreen = currentScreen->nextScreen;	} while (currentScreen);	if (checkBoxValue == 0)	{		(**gPrefs).prefsScreen = returnValue;		UpdatePreferences();	}	return returnValue;}Boolean	ChangeResolution(void){	ScreenInfoPtr	currentScreen;	Boolean			done = false;		currentScreen = firstScreen;		do {		if (currentScreen->theGDevice == theUserInterface.gameGDevice) done = true;		else currentScreen = currentScreen->nextScreen;			// TODO - any possibility to get stuck here ? shouldn't think so	} while (!done);	originalRec.screenDevice = currentScreen->theVideoRequest.screenDevice;		// this screen	RVGetCurrentVideoSetting(&originalRec);	// Set/Confirm/Reset the request	RVSetVideoRequest (&currentScreen->theVideoRequest);	if (noErr != RVConfirmVideoRequest (&currentScreen->theVideoRequest))	{		RVSetVideoRequest (&originalRec);		return false;				// TODO - couldn't change screen resolution, so should bomb out	}		return true;}void	RestoreResolution(void){	// attempt to reset the world to screen prefs setting (may not do anything with old video drivers)	RVSetVideoAsScreenPrefs ();}OSErr RVRequestVideoSetting (VideoRequestRecPtr requestRecPtr){	Boolean							displayMgrPresent;	short							iCount = 0;					// just a counter of GDevices we have seen	DMDisplayModeListIteratorUPP	myModeIteratorProc = nil;	// for DM2.0 searches	SpBlock							spBlock;	Boolean							suppliedGDevice;		DisplayIDType					theDisplayID;				// for DM2.0 searches	DMListIndexType					theDisplayModeCount;		// for DM2.0 searches	DMListType						theDisplayModeList;			// for DM2.0 searches	long							value = 0;	GDHandle						walkDevice = nil;			// for everybody	OSErr							gestaltErr;	unsigned long					displayMgrVersion;	Boolean 						hasDM2 = false;	Boolean 						hasSlotMgr = false;		gestaltErr = Gestalt(gestaltDisplayMgrVers, (long*)&displayMgrVersion);	if (	gestaltErr == noErr &&#if GENERATINGCFM			(Ptr) DMNewDisplayModeList != (Ptr) kUnresolvedCFragSymbolAddress &&			(Ptr) DMDisposeList != (Ptr) kUnresolvedCFragSymbolAddress &&#endif			displayMgrVersion >= 0x00020000	)	{		hasDM2 = true;	}	Gestalt(gestaltDisplayMgrAttr,&value);	displayMgrPresent=value&(1<<gestaltDisplayMgrPresent);	hasSlotMgr = (SVersion(&spBlock)==noErr);	//DL	displayMgrPresent=displayMgrPresent && (hasDM2 || hasSlotMgr);	//DL - need slot manager only if using DM 1.0.	if (!displayMgrPresent) return (-1); // return an error	// init the needed data before we start	if (requestRecPtr->screenDevice)							// user wants a specifc device?	{		walkDevice = requestRecPtr->screenDevice;		suppliedGDevice = true;	}	else	{		walkDevice = DMGetFirstScreenDevice (dmOnlyActiveDisplays);			// for everybody		suppliedGDevice = false;	}		myModeIteratorProc = NewDMDisplayModeListIteratorProc(ModeListIterator);	// for DM2.0 searches	// Note that we are hosed if somebody changes the gdevice list behind our backs while we are iterating....	// ...now do the loop if we can start	if( walkDevice && myModeIteratorProc) do // start the search	{		iCount++;		// GDevice we are looking at (just a counter)		if( noErr == DMGetDisplayIDByGDevice( walkDevice, &theDisplayID, false ) )	// DM1.0 does not need this, but it fits in the loop		{			theDisplayModeCount = 0;	// for DM2.0 searches			if (hasDM2 && noErr == DMNewDisplayModeList(theDisplayID, 0, 0, &theDisplayModeCount, &theDisplayModeList) )			{				// search NuBus & PCI the new kool way through Display Manager 2.0				GetRequestTheDM2Way (requestRecPtr, walkDevice, myModeIteratorProc, theDisplayModeCount, &theDisplayModeList);				DMDisposeList(theDisplayModeList);	// now toss the lists for this gdevice and go on to the next one			}			else FatalError("Needs Display Manager 2.0 or higher", false);		}	} while ( !suppliedGDevice && nil != (walkDevice = DMGetNextScreenDevice ( walkDevice, dmOnlyActiveDisplays )) );	// go until no more gdevices	if( myModeIteratorProc ) DisposeRoutineDescriptor(myModeIteratorProc);	if ((requestRecPtr->availBitDepth == 16) && (requestRecPtr->availHorizontal >= 640) && (requestRecPtr->availVertical >= 480))	{		return noErr;	}	else return (-1);	return (noErr);	// we were able to get the look for a match}OSErr RVGetCurrentVideoSetting (VideoRequestRecPtr requestRecPtr){	unsigned long		displayMgrVersion;	OSErr				error = paramErr;	CntrlParam			pBlock;	VDSwitchInfoRec		switchInfo;	AuxDCEHandle		theDCE;	VDSwitchInfoRec		videoMode;			requestRecPtr->availBitDepth			= 0;	// init to default - you can do it if it is important to you	requestRecPtr->availHorizontal			= 0;	requestRecPtr->availVertical			= 0;	requestRecPtr->availFlags				= 0;	requestRecPtr->displayMode				= -1; 	requestRecPtr->depthMode				= -1;	requestRecPtr->switchInfo.csMode		= 0;	requestRecPtr->switchInfo.csData		= 0;	requestRecPtr->switchInfo.csPage		= 0;	requestRecPtr->switchInfo.csBaseAddr	= 0;	requestRecPtr->switchInfo.csReserved	= 0;		Gestalt(gestaltDisplayMgrVers, (long*)&displayMgrVersion);	if (requestRecPtr->screenDevice)	{//DL -	must also make sure that Display Library is installed, otherwise//		calling DMGetDisplayMode() will branch to nil.//DL		if (displayMgrVersion >= 0x00020000)#if GENERATINGCFM		if (displayMgrVersion >= 0x00020000 && (Ptr) DMGetDisplayMode != (Ptr) kUnresolvedCFragSymbolAddress)#else		if (displayMgrVersion >= 0x00020000)#endif		{	// get the info the DM 2.0 way			error = DMGetDisplayMode(requestRecPtr->screenDevice, &switchInfo);			if (noErr == error)			{				requestRecPtr->depthMode			= switchInfo.csMode;				requestRecPtr->displayMode			= switchInfo.csData; 				requestRecPtr->switchInfo.csMode	= switchInfo.csMode;				requestRecPtr->switchInfo.csData	= switchInfo.csData;			}			return (error);	// we (maybe) set the world back to a known setting		}		else		{	// get the info the DM 1.0 way			videoMode.csMode = -1;		// init to bogus value			videoMode.csData = -1;		// init to bogus value						pBlock.ioNamePtr = nil;			pBlock.ioCRefNum = (*(requestRecPtr->screenDevice))->gdRefNum;			pBlock.csCode = cscGetCurMode;			*(Ptr *)&pBlock.csParam[0] = (Ptr)&videoMode;							error = PBStatusSync((ParmBlkPtr )&pBlock);	// ask the driver first....since we trust it the most							if ( noErr == error && ((-1 == videoMode.csMode) || (-1 == videoMode.csData)) )				error = statusErr;						if (noErr != error)	// if the driver has no clue fill it videoMode by hand as a last resort			{					theDCE = (AuxDCEHandle)GetDCtlEntry((*(requestRecPtr->screenDevice))->gdRefNum);								if( theDCE )				{					videoMode.csData = (unsigned char)(*theDCE)->dCtlSlotId; 					videoMode.csMode = (*(requestRecPtr->screenDevice))->gdMode;					error = noErr;				}			}			if (noErr == error)	// Set our data			{				requestRecPtr->displayMode			= videoMode.csData; 				requestRecPtr->depthMode			= videoMode.csMode;				requestRecPtr->switchInfo.csMode	= videoMode.csMode;				requestRecPtr->switchInfo.csData	= videoMode.csData;			}			return (error);	// we (maybe) set the world back to a known setting		}	}	return (-1);}//--------------------------------------------------------------//// Implementation of sample code////--------------------------------------------------------------OSErr RVSetVideoRequest (VideoRequestRecPtr requestRecPtr){	GDHandle		aMonitor;	Boolean			displayMgrPresent;	unsigned long	displayMgrVersion;	OSErr			err;	Boolean			isColor;	long			value = 0;	Gestalt(gestaltDisplayMgrVers, (long*)&displayMgrVersion);	Gestalt(gestaltDisplayMgrAttr,&value);	displayMgrPresent=value&(1<<gestaltDisplayMgrPresent);	if (displayMgrPresent)	{		if (requestRecPtr->displayMode && requestRecPtr->depthMode)		{			if (requestRecPtr->availBitDepth == 1)	// Based on avail bit depth, 				isColor = KMonoDev;					// set the device to a mono device, or			else isColor = kColorDev;				// set the device to a color device			SetDeviceAttribute(requestRecPtr->screenDevice,gdDevType,isColor);								// see how many monitors we have, aMonitor will be nil if we have only one.			aMonitor = DMGetFirstScreenDevice (dmOnlyActiveDisplays);			// get the first guy			aMonitor = DMGetNextScreenDevice ( aMonitor, dmOnlyActiveDisplays );	// get the next guy						if (nil == aMonitor || displayMgrVersion >= 0x00020000)			{				// only call DMSetDisplayMode if we have one monitor or DM2.0 is installed				// since DM1.0 does not automatically gravitate monitors and our gravitate code				// is not implemented.				err = DMSetDisplayMode(	requestRecPtr->screenDevice,	// GDevice						requestRecPtr->displayMode,						// DM1.0 uses this						&requestRecPtr->depthMode,						// DM1.0 uses this						(unsigned long) &(requestRecPtr->switchInfo),	// DM2.0 uses this rather than displayMode/depthMode combo						nil);				if (noErr == err)				{					// Do the monitor gravitate here if we are using a version less than DM2.0					if (displayMgrVersion < 0x00020000)						GravitateMonitors ();				}				else if (kDMDriverNotDisplayMgrAwareErr == err)				{					// DM not supported by driver, so all we can do is set the bit depth					err = SetDepth (requestRecPtr->screenDevice, requestRecPtr->depthMode, gdDevType, isColor);				}			}			else			{				// we have more than one monitor and DM1.0 is installed, so all we can do is set the bit depth				err = SetDepth (requestRecPtr->screenDevice, requestRecPtr->depthMode, gdDevType, isColor);			}						return (err);	// we did try to set the request		}	}	return (-1);	// return a generic error}OSErr RVConfirmVideoRequest (VideoRequestRecPtr requestRecPtr){	short			alertReturn;		// Alert() return value	ModalFilterUPP	confirmFilterUPP;	// got to have us one of them new fangled UPP thingies		if (requestRecPtr->availFlags & 1<<kModeValidNotSafeBit)	{		// new mode is valid but not safe, so ask user to confirm		SetCursor(&qd.arrow);										// have to show the arrow		confirmFilterUPP = NewModalFilterProc (ConfirmAlertFilter);	// create a new modal filter proc UPP		alertReturn = Alert(rConfirmSwtchAlrt, confirmFilterUPP);	// alert the user		DisposeRoutineDescriptor (confirmFilterUPP);				// of course there is no DisposeModalFilterProc...				if (alertReturn != iConfirmItem)			return (-1);							// tell the caller to switch back to a known setting		else return (noErr);						// all is well with the new setting, just leave it	}	return (noErr);									// the mode was safe, so do nothing}OSErr RVSetVideoAsScreenPrefs (void){	Handle		displaystate;	Boolean		displayMgrPresent;	long		value = 0;	Gestalt(gestaltDisplayMgrAttr,&value);	displayMgrPresent=value&(1<<gestaltDisplayMgrPresent);	if (displayMgrPresent)	{		DMBeginConfigureDisplays (&displaystate);	// Tell the world it is about to change		DMUseScreenPrefs (true, displaystate);		// Make the change		DMEndConfigureDisplays (displaystate);		// Tell the world the change is over				return (noErr);	// we (maybe) set the world back to a known setting	}	return (-1);	// return a generic error}pascal Boolean ConfirmAlertFilter(DialogRef theDialog, EventRecord *theEvent, short *itemHit){	char charCode;	Boolean enterORreturn;	Boolean returnValue = false;	WindowRef dialogWindow = GetDialogWindow(theDialog);	//DL	if (0 == GetWRefCon(dialogWindow))		SetWRefCon (dialogWindow,TickCount());	else	{		if (GetWRefCon(dialogWindow) + kSecondsToConfirm * 60 < TickCount())		{			returnValue = true;			theEvent->what = nullEvent;			*itemHit = 1;		}		else		{			if (theEvent->what == keyDown)			{				charCode = (char)theEvent->message & charCodeMask;				enterORreturn = (charCode == (char)char_Return) || (charCode == (char)char_Enter);				if (enterORreturn)				{					theEvent->what = nullEvent;					returnValue = true;					*itemHit = iRevertItem;					if (enterORreturn && (0 != (theEvent->modifiers & optionKey)))					{						*itemHit = iConfirmItem;					}				}			}		}	}	return (returnValue);}void GetRequestTheDM2Way (	VideoRequestRecPtr requestRecPtr,							GDHandle walkDevice,							DMDisplayModeListIteratorUPP myModeIteratorProc,							DMListIndexType theDisplayModeCount,							DMListType *theDisplayModeList){	short					jCount;	short					kCount;	ListIteratorDataRec		searchData;	searchData.depthBlocks = nil;	// get the mode lists for this GDevice	for (jCount=0; jCount<theDisplayModeCount; jCount++)		// get info on all the resolution timings	{		DMGetIndexedDisplayModeFromList(*theDisplayModeList, jCount, 0, myModeIteratorProc, &searchData);				// for all the depths for this resolution timing (mode)...		if (searchData.depthBlockCount) for (kCount = 0; kCount < searchData.depthBlockCount; kCount++)		{			// only if the mode is valid and is safe or we override it with the kBitDepthPriorityBit request flag/*			if	(	searchData.displayModeTimingInfo.csTimingFlags & 1<<kModeValid && 					(	searchData.displayModeTimingInfo.csTimingFlags & 1<<kModeSafe ||						requestRecPtr->requestFlags & 1<<kBitDepthPriorityBit					)				)*/			if	(searchData.displayModeTimingInfo.csTimingFlags & 1<<kModeValid &&								searchData.displayModeTimingInfo.csTimingFlags & 1<<kModeSafe)			{				if (FindBestMatch (	requestRecPtr,									searchData.depthBlocks[kCount].depthVPBlock.vpPixelSize,									searchData.depthBlocks[kCount].depthVPBlock.vpBounds.right,									searchData.depthBlocks[kCount].depthVPBlock.vpBounds.bottom))				{					requestRecPtr->screenDevice = walkDevice;					requestRecPtr->availBitDepth = searchData.depthBlocks[kCount].depthVPBlock.vpPixelSize;					requestRecPtr->availHorizontal = searchData.depthBlocks[kCount].depthVPBlock.vpBounds.right;					requestRecPtr->availVertical = searchData.depthBlocks[kCount].depthVPBlock.vpBounds.bottom;										// now set the important info for DM to set the display					requestRecPtr->depthMode = searchData.depthBlocks[kCount].depthSwitchInfo.csMode;					requestRecPtr->displayMode = searchData.depthBlocks[kCount].depthSwitchInfo.csData;					requestRecPtr->switchInfo = searchData.depthBlocks[kCount].depthSwitchInfo;					if (searchData.displayModeTimingInfo.csTimingFlags & 1<<kModeSafe)						requestRecPtr->availFlags = 0;							// mode safe					else requestRecPtr->availFlags = 1<<kModeValidNotSafeBit;	// mode valid but not safe, requires user validation of mode switch					}			}		}			if (searchData.depthBlocks)		{			DisposePtr ((Ptr)searchData.depthBlocks);	// toss for this timing mode of this gdevice			searchData.depthBlocks = nil;				// init it just so we know		}	}}pascal void ModeListIterator(void *userData, DMListIndexType, DMDisplayModeListEntryPtr displaymodeInfo){	unsigned long			depthCount;	short					iCount;	ListIteratorDataRec		*myIterateData		= (ListIteratorDataRec*) userData;	DepthInfo				*myDepthInfo;		// set user data in a round about way	myIterateData->displayModeTimingInfo		= *displaymodeInfo->displayModeTimingInfo;		// now get the DMDepthInfo info into memory we own	depthCount = displaymodeInfo->displayModeDepthBlockInfo->depthBlockCount;	myDepthInfo = (DepthInfo*)NewPtrClear(depthCount * sizeof(DepthInfo));	// set the info for the caller	myIterateData->depthBlockCount = depthCount;	myIterateData->depthBlocks = myDepthInfo;	// and fill out all the entries	if (depthCount) for (iCount=0; iCount < depthCount; iCount++)	{		myDepthInfo[iCount].depthSwitchInfo = 			*displaymodeInfo->displayModeDepthBlockInfo->depthVPBlock[iCount].depthSwitchInfo;		myDepthInfo[iCount].depthVPBlock = 			*displaymodeInfo->displayModeDepthBlockInfo->depthVPBlock[iCount].depthVPBlock;	}}Boolean FindBestMatch (VideoRequestRecPtr requestRecPtr, short bitDepth, unsigned long horizontal, unsigned long vertical){	// ¥¥ do the big comparison ¥¥	// first time only if	(no mode yet) and	//						(bounds are greater/equal or kMaximizeRes not set) and	//						(depth is less/equal or kShallowDepth not set) and	//						(request match or kAbsoluteRequest not set)	if	(	nil == requestRecPtr->displayMode			&&			(	(horizontal >= requestRecPtr->reqHorizontal &&				vertical >= requestRecPtr->reqVertical)				||																		!(requestRecPtr->requestFlags & 1<<kMaximizeResBit)				)			&&			(	bitDepth <= requestRecPtr->reqBitDepth ||					!(requestRecPtr->requestFlags & 1<<kShallowDepthBit)					)			&&			(	(horizontal == requestRecPtr->reqHorizontal &&					vertical == requestRecPtr->reqVertical &&				bitDepth == requestRecPtr->reqBitDepth)				||				!(requestRecPtr->requestFlags & 1<<kAbsoluteRequestBit)				)		)		{			// go ahead and set the new values			return (true);		}	else	// can we do better than last time?	{		// if	(kBitDepthPriority set and avail not equal req) and		//		((depth is greater avail and depth is less/equal req) or kShallowDepth not set) and		//		(avail depth less reqested and new greater avail) or		//		(request match or kAbsoluteRequest not set)		if	(	(	requestRecPtr->requestFlags & 1<<kBitDepthPriorityBit && 					requestRecPtr->availBitDepth != requestRecPtr->reqBitDepth				)				&&				(	(	bitDepth > requestRecPtr->availBitDepth &&						bitDepth <= requestRecPtr->reqBitDepth					)					||					!(requestRecPtr->requestFlags & 1<<kShallowDepthBit)					)				&&				(	requestRecPtr->availBitDepth < requestRecPtr->reqBitDepth &&					bitDepth > requestRecPtr->availBitDepth					)				&&				(	(horizontal == requestRecPtr->reqHorizontal &&						vertical == requestRecPtr->reqVertical &&					bitDepth == requestRecPtr->reqBitDepth)					||					!(requestRecPtr->requestFlags & 1<<kAbsoluteRequestBit)					)			)		{			// go ahead and set the new values			return (true);		}		else		{			// match resolution: minimize Æh & Æv			if	(	abs((requestRecPtr->reqHorizontal - horizontal)) <=					abs((requestRecPtr->reqHorizontal - requestRecPtr->availHorizontal)) &&					abs((requestRecPtr->reqVertical - vertical)) <=					abs((requestRecPtr->reqVertical - requestRecPtr->availVertical))				)			{				// now we have a smaller or equal delta				//	if (h or v greater/equal to request or kMaximizeRes not set) 				if (	(horizontal >= requestRecPtr->reqHorizontal &&						vertical >= requestRecPtr->reqVertical)						||						!(requestRecPtr->requestFlags & 1<<kMaximizeResBit)					)				{					// if	(depth is equal or kBitDepthPriority not set) and					//		(depth is less/equal or kShallowDepth not set) and					//		([h or v not equal] or [avail depth less reqested and new greater avail] or depth equal avail) and					//		(request match or kAbsoluteRequest not set)					if	(	(	requestRecPtr->availBitDepth == bitDepth ||											!(requestRecPtr->requestFlags & 1<<kBitDepthPriorityBit)							)							&&							(	bitDepth <= requestRecPtr->reqBitDepth ||									!(requestRecPtr->requestFlags & 1<<kShallowDepthBit)									)							&&							(	(requestRecPtr->availHorizontal != horizontal ||								requestRecPtr->availVertical != vertical)								||								(requestRecPtr->availBitDepth < requestRecPtr->reqBitDepth &&								bitDepth > requestRecPtr->availBitDepth)								||								(bitDepth == requestRecPtr->reqBitDepth)							)							&&							(	(horizontal == requestRecPtr->reqHorizontal &&									vertical == requestRecPtr->reqVertical &&								bitDepth == requestRecPtr->reqBitDepth)								||								!(requestRecPtr->requestFlags & 1<<kAbsoluteRequestBit)								)						)					{						// go ahead and set the new values						return (true);					}				}			}		}	}	return (false);}void GravitateMonitors (void){	// do the magic gravitation here}