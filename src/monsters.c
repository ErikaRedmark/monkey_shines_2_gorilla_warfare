#include	"globals extern.h"void PlayMonsterSound(short, MonsterSpritePtr);MonsterSpritePtr AllocateMonster(void){	MonsterSpritePtr	tempSprite, temp;		tempSprite = (MonsterSpritePtr)NewPtrClear(sizeof(MonsterSprite));	if (tempSprite == nil) FatalError("Sprite Allocation Failed", true);	if (firstMonster == nil) firstMonster = tempSprite;	else	{		// find the last monster in the list				temp = firstMonster;			while (temp->nextSprite != nil) temp = temp->nextSprite;			temp->nextSprite = tempSprite;		tempSprite->prevSprite = temp;	}	return tempSprite;}/* Routine to dispose of a monster - make the list pass over the sprite *//* then release the memory occupied by the sprite */MonsterSpritePtr DisposeMonster(MonsterSpritePtr theSprite){	MonsterSpritePtr	returnValue;	MonsterSpritePtr	tempSprite = theSprite;	if (theSprite == nil) FatalError("Trying to dispose of zero sprite", true);	returnValue = theSprite->nextSprite;		if (theSprite->nextSprite == nil)	// must be the last monster in the list	{		if (theSprite == firstMonster) firstMonster = nil;	}	else if (theSprite == firstMonster)	{		firstMonster = theSprite->nextSprite;	}	if (tempSprite->nextSprite) (tempSprite->nextSprite)->prevSprite = tempSprite->prevSprite;	if (tempSprite->prevSprite) (tempSprite->prevSprite)->nextSprite = tempSprite->nextSprite;	DisposePtr( (Ptr)theSprite);	return returnValue;}void	HandleMonsters(Rect *drawingRect){	MonsterSpritePtr tempMonster = firstMonster;		while (tempMonster)	{		HandleOneMonster(tempMonster, drawingRect);		tempMonster = tempMonster->nextSprite;	}	// now do any need disposing ?		tempMonster = firstMonster;	while (tempMonster)	{		if (tempMonster->kind == kSpriteDone) tempMonster = DisposeMonster(tempMonster);		else tempMonster = tempMonster->nextSprite;	}}void HandleOneMonster(MonsterSpritePtr theMonster, Rect *drawingRect){	Rect	dummy;	short	h, v, insetH, insetV, width;	if (theMonster->room != theGlobals.theRoom)	{		theMonster->needToDraw = false;		return;	}	MoveMonster(theMonster, drawingRect);	if (SectRect(drawingRect, &theMonster->theRect, &dummy)) theMonster->needToDraw = true;	else theMonster->needToDraw = false;		// check if the monster has moved out of the play area		if ((theMonster->theRect.left < 0) || (theMonster->theRect.right > roomWidthPixels) || (theMonster->theRect.top < 0)		|| (theMonster->theRect.bottom > roomHeightPixels))	{		theMonster->kind = kSpriteDone;		theMonster->needToDraw = false;	}		if (theMonster->needToDraw == false) return;	insetH = 0;	insetV = 0;	theMonster->drawingHeight = dummy.bottom - dummy.top;	theMonster->drawingWidth = dummy.right - dummy.left;		theMonster->inset = 0; // for invert blitter		if (theMonster->drawingWidth != (theMonster->theRect.right - theMonster->theRect.left))	{		// need to clip horizontally			if (theMonster->theRect.left < drawingRect->left)		{			insetH = drawingRect->left - theMonster->theRect.left;						if (theMonster->directionFacing == directionLeft) theMonster->inset = 0;			else theMonster->inset = insetH;						// right		}		else if (theMonster->theRect.right > drawingRect->right)		{			if (theMonster->directionFacing == directionLeft) theMonster->inset = theMonster->theRect.right - drawingRect->right;		}	}	if (theMonster->drawingHeight != (theMonster->theRect.bottom - theMonster->theRect.top))	{		// need to clip  vertically			if (theMonster->theRect.top < drawingRect->top) insetV = drawingRect->top - theMonster->theRect.top;	}		// now prepare the sprite for drawing	width = theMonster->theRect.right - theMonster->theRect.left;	h = theMonster->theRect.left - (24 * minActualHoriz);	v = theMonster->theRect.top - (24 * minActualVert);	theMonster->source = (short *)(theGWorlds.monsterMemPtr[theMonster->subKind] + 2 * ((width * theMonster->frame))										+ (insetV * theMonster->sourceRowBytes));	theMonster->dest = (short *)(theGWorlds.safeMemPtr + ((v + insetV) * theGWorlds.safeRowOffSet) + 2 * (h + insetH));}void MoveMonster(MonsterSpritePtr theMonster, Rect *drawingRect){	short	direction;	Rect	dummy;	Boolean	move;	direction = 100 - ((100 * theMonster->hitPoints)/theMonster->maxHitPoints);		if (direction <= (theMonster->aggression * 20)) direction = 1;	// towards Darwin	else direction = 0;		// away	// so the monster is in the current room. decide if it should move	// expand the drawing rect to see if the monster is close to the visible part of the screen		dummy.left = drawingRect->left - 100;	dummy.right = drawingRect->right + 100;	dummy.top = drawingRect->top - 100;	dummy.bottom = drawingRect->bottom + 100;		if (SectRect(&dummy, &theMonster->theRect, &dummy)) move = true; // close enough to move	else move = false;	switch (theMonster->spriteMovement)	{		case spriteMovementStatic: // no movement			break;		case spriteMovementHorizontal:	// simple horizontal movement			MonsterHorizontal(theMonster);			break;		case spriteMovementHorizontalWalking:			MonsterHorizontalWalking(theMonster);			break;		case spriteMovementVertical:			MonsterVertical(theMonster);			break;		case spriteMovementWalk:			if (move) MonsterWalk(theMonster, direction);			break;		case spriteMovementFly:			if (move) MonsterFly(theMonster, direction);			break;	}	if (--theMonster->animationCounter == 0)	{		theMonster->frame++;		if (theMonster->frame >= theMonster->frames) theMonster->frame = 0;				if ((theMonster->frame == (**spriteDefinitions[theMonster->subKind]).specialFrame) &&				((**spriteDefinitions[theMonster->subKind]).SCRTID != 0))		{			// we are on the special frame, and there is a script for it					HandleScript(theMonster, (**spriteDefinitions[theMonster->subKind]).SCRTID);				}				theMonster->animationCounter = theMonster->animationSpeed;	}		// if there is something to be done if the monster is level with Darwin, handle it		if ((**spriteDefinitions[theMonster->subKind]).horizontalSCRT != 0)	{		// find the centre of the sprite				if (abs((theMonster->theRect.top + theMonster->theRect.bottom)/2 - (player.theRect.top + player.theRect.bottom)/2) < (**spriteDefinitions[theMonster->subKind]).tolerance)		{			HandleScript(theMonster, (**spriteDefinitions[theMonster->subKind]).horizontalSCRT);		}		}		if ((**spriteDefinitions[theMonster->subKind]).verticalSCRT != 0)	{		// find the centre of the sprite				if (abs((theMonster->theRect.left + theMonster->theRect.right)/2 - (player.theRect.left + player.theRect.right)/2) < (**spriteDefinitions[theMonster->subKind]).tolerance)		{			HandleScript(theMonster, (**spriteDefinitions[theMonster->subKind]).verticalSCRT);		}	}	if ((**spriteDefinitions[theMonster->subKind]).closeSCRT != 0)	{		Rect	tempRect, dummy;				SetRect(&tempRect, theMonster->theRect.left - (**spriteDefinitions[theMonster->subKind]).tolerance,							theMonster->theRect.top - (**spriteDefinitions[theMonster->subKind]).tolerance,							theMonster->theRect.right + (**spriteDefinitions[theMonster->subKind]).tolerance,							theMonster->theRect.bottom + (**spriteDefinitions[theMonster->subKind]).tolerance);				if (SectRect(&tempRect, &player.theRect, &dummy))		{			HandleScript(theMonster, (**spriteDefinitions[theMonster->subKind]).closeSCRT);		}	}	}void	MonsterHorizontal(MonsterSpritePtr	theMonster){	if (theMonster->directionMoving == directionRight)	{		if (MoveMonsterRightSimple(theMonster, theMonster->maxSpeed) < theMonster->maxSpeed)		{			// turn						theMonster->directionMoving = directionLeft;		}	}	else	{		if (MoveMonsterLeftSimple(theMonster, theMonster->maxSpeed) < theMonster->maxSpeed)		{			// turn						theMonster->directionMoving = directionRight;		}	}		theMonster->directionFacing = theMonster->directionMoving;}void	MonsterHorizontalWalking(MonsterSpritePtr	theMonster){	if (theMonster->directionMoving == directionRight)	{		if (MoveMonsterRight(theMonster, theMonster->maxSpeed) < theMonster->maxSpeed)		{			// turn						theMonster->directionMoving = directionLeft;		}	}	else	{		if (MoveMonsterLeft(theMonster, theMonster->maxSpeed) < theMonster->maxSpeed)		{			// turn						theMonster->directionMoving = directionRight;		}	}		theMonster->directionFacing = theMonster->directionMoving;}void	MonsterVertical(MonsterSpritePtr	theMonster){	if (theMonster->directionMoving == directionDown)	// down	{		if (MoveMonsterDown(theMonster, theMonster->maxSpeed) < theMonster->maxSpeed)		{			// turn						theMonster->directionMoving = directionUp;	// up		}	}	else	{		if (MoveMonsterUp(theMonster, theMonster->maxSpeed) < theMonster->maxSpeed)		{			// turn						theMonster->directionMoving = directionDown;		}	}		theMonster->directionFacing = directionRight; // don't flip}// walking monster - direction = 1, towards Darwin, direction = 0, away from Darwinvoid	MonsterWalk(MonsterSpritePtr	theMonster, short direction){	short wantedDirection;			if (direction == 0)	{		if (theMonster->theRect.left < player.theRect.left) wantedDirection = 1;	// left		else wantedDirection = directionRight;	// right	}	else	{		if (theMonster->theRect.left < player.theRect.left) wantedDirection = 0;	// right		else wantedDirection = directionLeft;	// left	}		// check which direction the sprite is actually moving, and if it's the wrong way, count down	// to when it can turn		if (wantedDirection != theMonster->directionFacing)	{		theMonster->directionCount--;		if (theMonster->directionCount == 0)		{			theMonster->directionFacing = wantedDirection;			theMonster->directionCount = 15;		}	}	else theMonster->directionCount = 15;	if (theMonster->directionFacing == directionLeft)	{		MoveMonsterLeft(theMonster, theMonster->maxSpeed);//		theMonster->directionFacing = 1; // left	}	else if (theMonster->directionFacing == directionRight)	{		MoveMonsterRight(theMonster, theMonster->maxSpeed);//		theMonster->directionFacing = 0; // right	}}// flying monster - direction = 1, towards Darwin, direction = 0, away from Darwinvoid	MonsterFly(MonsterSpritePtr	theMonster, short direction){	short wantedDirection;			// handle horizontal movement first	if (direction == 0)	{		if (theMonster->theRect.left < player.theRect.left) wantedDirection = 1;	// left		else wantedDirection = 0;	// right	}	else	{		if (theMonster->theRect.left < player.theRect.left) wantedDirection = 0;	// right		else wantedDirection = 1;	// left	}		// check which direction the sprite is actually moving, and if it's the wrong way, count down	// to when it can turn		if (wantedDirection != theMonster->directionFacing)	{		theMonster->directionCount--;		if (theMonster->directionCount == 0)		{			theMonster->directionFacing = wantedDirection;			theMonster->directionCount = 15;		}	}	else theMonster->directionCount = 15;		if (theMonster->directionFacing == directionLeft)	{		MoveMonsterLeftSimple(theMonster, theMonster->maxSpeed);		//		theMonster->directionFacing = 1; // left	}	else if (theMonster->directionFacing == directionRight)	{		MoveMonsterRightSimple(theMonster, theMonster->maxSpeed);//		theMonster->directionFacing = 0; // right	}	// then handle vertical movement	if (direction == 0)	{		if (theMonster->theRect.top < player.theRect.top) wantedDirection = 1;	// up		else wantedDirection = 0;	// down	}	else	{		if (theMonster->theRect.top < player.theRect.top) wantedDirection = 0;	// down		else wantedDirection = 1;	// up	}		if (wantedDirection == 1) MoveMonsterUp(theMonster, theMonster->maxSpeed);	else if (wantedDirection == 0) MoveMonsterDown(theMonster, theMonster->maxSpeed);}// falling projectile/*void	MonsterFall(MonsterSpritePtr theMonster){	short test, ignore;		if (theMonster->frame == 0) // not yet hit ground	{		ignore = TestMoveSpriteDown(&theMonster->theRect, 4, &test); // 4 pixels for falling - add gravity		theMonster->theRect.top += test;		theMonster->theRect.bottom += test;				if (test < 4) theMonster->frame++;	// hit ground, so start animation	}		// might have now hit the ground		if (theMonster->frame != 0)	{		if (theMonster->frame == theMonster->frames) theMonster->kind = kSpriteDone;		else if (frameCount & 2) theMonster->frame++; // slow down the animation	}}*/short	MoveMonsterLeftSimple(MonsterSpritePtr theMonster, short pixels){	short test;		test = TestMoveSpriteLeft(&theMonster->theRect, pixels);	theMonster->theRect.left -= test;	theMonster->theRect.right -= test;		if (test < pixels)	{		// is there a collision script				if ((**spriteDefinitions[theMonster->subKind]).collisionSCRT != 0)		{			HandleScript(theMonster, (**spriteDefinitions[theMonster->subKind]).collisionSCRT);		}		}		return test;}short	MoveMonsterRightSimple(MonsterSpritePtr theMonster, short pixels){	short test;		test = TestMoveSpriteRight(&theMonster->theRect, pixels);	theMonster->theRect.left += test;	theMonster->theRect.right += test;	if (test < pixels)	{		// is there a collision script				if ((**spriteDefinitions[theMonster->subKind]).collisionSCRT != 0)		{			HandleScript(theMonster, (**spriteDefinitions[theMonster->subKind]).collisionSCRT);		}		}		return test;}short	MoveMonsterLeft(MonsterSpritePtr theMonster, short pixels){	short test, test2;		test = TestMoveSpriteLeft(&theMonster->theRect, pixels);		if (test > 0)	{		// nothing to the left of the monster, so check if it will walk off a platform			test2 = TestSpriteWalkOffPlatformLeft(&theMonster->theRect, pixels);		if (test2 < test) test = test2;		}	theMonster->theRect.left -= test;	theMonster->theRect.right -= test;		return test;}short	MoveMonsterRight(MonsterSpritePtr theMonster, short pixels){	short test, test2;		test = TestMoveSpriteRight(&theMonster->theRect, pixels);	if (test > 0)	{		// nothing to the left of the monster, so check if it will walk off a platform			test2 = TestSpriteWalkOffPlatformRight(&theMonster->theRect, pixels);		if (test2 < test) test = test2;		}	theMonster->theRect.left += test;	theMonster->theRect.right += test;		return test;}short	MoveMonsterUp(MonsterSpritePtr theMonster, short pixels){	short test;		test = TestMoveSpriteUp(&theMonster->theRect, pixels);	if (test < pixels)	{		// is there a collision script				if ((**spriteDefinitions[theMonster->subKind]).collisionSCRT != 0)		{			HandleScript(theMonster, (**spriteDefinitions[theMonster->subKind]).collisionSCRT);		}		}	theMonster->theRect.top -= test;	theMonster->theRect.bottom -= test;		return test;}short	MoveMonsterDown(MonsterSpritePtr theMonster, short pixels){	short test, ignore;		ignore = TestMoveSpriteDown(&theMonster->theRect, pixels, &test);	if (test < pixels)	{		// is there a collision script				if ((**spriteDefinitions[theMonster->subKind]).collisionSCRT != 0)		{			HandleScript(theMonster, (**spriteDefinitions[theMonster->subKind]).collisionSCRT);		}		}	theMonster->theRect.top += test;	theMonster->theRect.bottom += test;	return test;}void	HandleScript(MonsterSpritePtr theMonster, short whichScript){	if (spriteScripts[whichScript - 128] == nil) FatalError("Missing sprite script", true);	if ((**spriteScripts[whichScript - 128]).probability == 0)	{		// check frequency			if ((**spriteScripts[whichScript - 128]).frequency == 0)		{			// might need to play a sound and destroy the sprite						if ((**spriteScripts[whichScript - 128]).sound > 0)	PlayMonsterSound((**spriteScripts[whichScript - 128]).sound - 1, theMonster);			if ((**spriteScripts[whichScript - 128]).destroyOriginal == true) theMonster->kind = kSpriteDone;		}		else		{			if (theMonster->frequency++ == (**spriteScripts[whichScript - 128]).frequency)			{				theMonster->frequency = 0;								// now run the script								RunScript(theMonster, whichScript);								#ifdef DEMO					if (hackedFive) FatalError("Error in Monster Script", true);				#endif			}		}		}	else if ((**spriteScripts[whichScript - 128]).probability == 100)	{		// run the script				RunScript(theMonster, whichScript);			}	else	{		short	randomShort;		float	randomNumber;				randomShort = abs(Random());		randomNumber = (float)randomShort / 327.67;	// gives 0 - 100				randomShort = (short)randomNumber;				if (randomShort < (**spriteScripts[whichScript - 128]).probability)		{			// run the script						RunScript(theMonster, whichScript);		}	}}void	RunScript(MonsterSpritePtr	theMonster, short	whichScript){	MonsterSpritePtr	tempSprite;	Rect				tempRect;	Boolean				create = true;	if ((**spriteScripts[whichScript - 128]).resourceID > 1000)	{		// must have to create a new sprite				// first check if the sprite can be created				if (theMonster->directionFacing == directionRight)		{			tempRect.left = theMonster->theRect.left + (**spriteScripts[whichScript - 128]).offsetH;			tempRect.right = tempRect.left + (**spriteDefinitions[(**spriteScripts[whichScript - 128]).resourceID - 1000]).width;			tempRect.top = theMonster->theRect.top + (**spriteScripts[whichScript - 128]).offsetV;			tempRect.bottom = tempRect.top + (**spriteDefinitions[(**spriteScripts[whichScript - 128]).resourceID - 1000]).height;						if (TestMoveSpriteRight(&tempRect, 1) == 0) create = false;		}		else		{			tempRect.right = theMonster->theRect.right - (**spriteScripts[whichScript - 128]).offsetH;			tempRect.left = tempRect.right - (**spriteDefinitions[(**spriteScripts[whichScript - 128]).resourceID - 1000]).width;			tempRect.top = theMonster->theRect.top + (**spriteScripts[whichScript - 128]).offsetV;			tempRect.bottom = tempRect.top + (**spriteDefinitions[(**spriteScripts[whichScript - 128]).resourceID - 1000]).height;			if (TestMoveSpriteLeft(&tempRect, 1) == 0) create = false;		}		if (create)		{			tempSprite = AllocateMonster();			tempSprite->kind = maskMonster;			tempSprite->subKind = (**spriteScripts[whichScript - 128]).resourceID - 1000;	// TODO - subtract 1000 ? Check			tempSprite->spriteType = (**spriteDefinitions[tempSprite->subKind]).spriteType;			tempSprite->spriteMovement = (**spriteDefinitions[tempSprite->subKind]).spriteMovement;			tempSprite->layer = (**spriteDefinitions[tempSprite->subKind]).spriteLayer;			tempSprite->room = theGlobals.theRoom;						// use the default max speed, etc.			tempSprite->maxSpeed = 3 * (**spriteDefinitions[tempSprite->subKind]).speed;			tempSprite->aggression = (**spriteDefinitions[tempSprite->subKind]).aggression;					tempSprite->frames = (**spriteDefinitions[tempSprite->subKind]).frames;			if ((**spriteScripts[whichScript - 128]).transferHitPoints)			{				tempSprite->hitPoints = theMonster->hitPoints;				tempSprite->maxHitPoints = theMonster->maxHitPoints;			}			else			{				tempSprite->hitPoints = (**spriteDefinitions[tempSprite->subKind]).hitPoints;				tempSprite->maxHitPoints = (**spriteDefinitions[tempSprite->subKind]).hitPoints;			}			if (theMonster->directionFacing == directionRight)			{				tempSprite->theRect.left = theMonster->theRect.left + (**spriteScripts[whichScript - 128]).offsetH;				tempSprite->theRect.right = tempSprite->theRect.left + (**spriteDefinitions[tempSprite->subKind]).width;				if (tempSprite->spriteMovement == spriteMovementVertical) tempSprite->directionMoving = directionDown;				else tempSprite->directionMoving = (**spriteScripts[whichScript - 128]).directionFacing;			}			else			{				tempSprite->theRect.right = theMonster->theRect.right - (**spriteScripts[whichScript - 128]).offsetH;				tempSprite->theRect.left = tempSprite->theRect.right - (**spriteDefinitions[tempSprite->subKind]).width;				if (tempSprite->spriteMovement == spriteMovementVertical) tempSprite->directionMoving = directionDown;				else tempSprite->directionMoving = !(**spriteScripts[whichScript - 128]).directionFacing;			}						tempSprite->directionFacing = tempSprite->directionMoving;					tempSprite->theRect.top = theMonster->theRect.top + (**spriteScripts[whichScript - 128]).offsetV;			tempSprite->theRect.bottom = tempSprite->theRect.top + (**spriteDefinitions[tempSprite->subKind]).height;							tempSprite->animationSpeed = (**spriteDefinitions[tempSprite->subKind]).animationSpeed;			tempSprite->animationCounter = tempSprite->animationSpeed;			tempSprite->bananaAction = (**spriteDefinitions[tempSprite->subKind]).bananaAction;			tempSprite->sourceRowBytes = (0x7FFF & (**theGWorlds.monsterPixMap[tempSprite->subKind]).rowBytes);	// only need to do this once			tempSprite->directionCount = 30;							if (tempSprite->spriteMovement == spriteMovementVertical) tempSprite->directionFacing = directionRight;			tempSprite->frame = 0;		}	}	if ((**spriteScripts[whichScript - 128]).sound > 0)	PlayMonsterSound((**spriteScripts[whichScript - 128]).sound - 1, theMonster);	if ((**spriteScripts[whichScript - 128]).destroyOriginal == true) theMonster->kind = kSpriteDone;}void PlayMonsterSound(short theSound, MonsterSpritePtr theMonster){	long distanceSquared;	distanceSquared = ((theMonster->theRect.left - player.theRect.left) * (theMonster->theRect.left - player.theRect.left))						+ ((theMonster->theRect.top - player.theRect.top) * (theMonster->theRect.top - player.theRect.top));	if (distanceSquared < 300000) PlayASound(theSound);}