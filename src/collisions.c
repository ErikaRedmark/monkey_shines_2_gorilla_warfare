#include	"globals extern.h"void HandleCollisions(void){	ItemSpritePtr		tempItem;	MonsterSpritePtr	tempMonster;	BananaSpritePtr		tempBanana;	HazardSpritePtr		tempHazard;	TalismanSpritePtr	tempTalisman;	DoorSpritePtr		tempDoor;	// handle collisions with player		if (!player.dying && !player.gDead)	{		// with items			tempItem = firstItem;				while (tempItem != nil)		{			if (tempItem->kind != maskItemInactive)			{					if (CheckPlayerCollision((CollisionSpritePtr)tempItem))	HandleItemCollision(tempItem);				else tempItem->darwinOverlapping = false;			}						tempItem = tempItem->nextSprite;		}				// with talisman				tempTalisman = firstTalisman;		while (tempTalisman != nil)		{			if (tempTalisman->subKind < 12)			{						if (CheckPlayerCollision((CollisionSpritePtr)tempTalisman)) HandleTalismanCollision(tempTalisman);			}			tempTalisman = tempTalisman->nextSprite;		}				// with small hazards		tempHazard = firstHazard;				while (tempHazard != nil)		{			if (CheckPlayerCollision((CollisionSpritePtr)tempHazard))			{			#ifndef DEMO				if (!invincible)				{			#endif					if (!(player.powerUp & shield))					{						SetupDeath();						PlayASound(sndSmallHazard1Death + tempHazard->subKind);					}			#ifndef DEMO				}			#endif			}									tempHazard = tempHazard->nextSprite;		}		// now check the monsters			tempMonster = firstMonster;				while (tempMonster != nil)		{			if (tempMonster->spriteType != spriteTypeScenery)			{				if (CheckPlayerCollision((CollisionSpritePtr)tempMonster))				{					// we have hit somthing - work out what, and handle it								#ifndef DEMO					if (!invincible)					{				#endif						if (!(player.powerUp & shield))						{							if (tempMonster->spriteType == spriteTypeKiller)							{								PlayASound(sndDarwinDie);								SetupDeath();							}							else							{								// collision, and not protected								#ifndef DEMO								if (theGlobals.difficulty == 0) player.gDarwinLife -= 2.5;								else player.gDarwinLife -= 4;							#else								player.gDarwinLife -= 4;							#endif								DrawLifeBar();																// need a 1/30 second sound for energy drain																if (player.gDarwinLife < 1)								{									PlayASound(sndDarwinDie);									SetupDeath();								}								else								{									SCStatus	theStatus;									SndChannelStatus(theAudioStuff.damageChannel, sizeof(SCStatus), &theStatus);									if (theStatus.scChannelBusy == false) DamageSound();								}							}						}				#ifndef DEMO					}				#endif					while (tempMonster->nextSprite != nil) tempMonster = tempMonster->nextSprite; // only register one collision per frame				}			}			tempMonster = tempMonster->nextSprite;		}				// now check the doors				if ((player.teleporting == 0) && !player.dying) // not already teleporting		{			tempDoor = firstDoor;						while (tempDoor != nil)			{				if (tempDoor->kind != maskDoorInactive)	// only check active doors				{					if ((tempDoor->doorNumber != 0) && CheckDoorCollision(tempDoor)) // don't allow player to enter door zero					{						// added check												if (tempDoor->doorNumber != tempDoor->doorDestination)						{							if (tempDoor->subKind == 0)	// wait for door to open							{								if (tempDoor->frame == 0)								{									player.enteredDoor = 0 - tempDoor->doorDestination; // allow time for the animation									player.teleporting = 3;									player.iconRow = timeMachineRow;									player.frame = 7;									PlayASound(sndEnterTimeMachine);								}							}							else							{								player.enteredDoor = 0 - tempDoor->doorDestination; // allow time for the animation								player.teleporting = 1; // teleporting out								PlayASound(sndDarwinTeleport);								player.frame = 12;								player.iconRow = teleportRow;							}														while (tempDoor->nextSprite != nil) tempDoor = tempDoor->nextSprite; // only register one collision per frame						}					}				}				tempDoor = tempDoor->nextSprite;			}		}	}	// now need to do the same for the bananas	tempBanana = firstBanana;		while (tempBanana != nil)	{		// first check if the banana has collided with a hazard				tempHazard = firstHazard;		while (tempHazard != nil)		{			if (CheckBananaCollision((CollisionSpritePtr)tempBanana, (CollisionSpritePtr)tempHazard))			{				if (player.powerUp & powerFire) PlayASound(sndPowerBananaHits);				else PlayASound(sndBananaHits);												tempBanana->bananaStatus = 25;	// destroy the banana								while  (tempHazard->nextSprite != nil) tempHazard = tempHazard->nextSprite; // only register one collision per frame			}			tempHazard = tempHazard->nextSprite;		}				tempMonster = firstMonster;					while (tempMonster != nil)		{			if (tempMonster->spriteType != spriteTypeScenery)			{				if (CheckBananaCollision((CollisionSpritePtr)tempBanana, (CollisionSpritePtr)tempMonster))				{				 	if (tempMonster->bananaAction == spriteBananaActionDamage)				 	{						// handle collisions with monsters												tempBanana->bananaStatus = 25;	// destroy the banana												if (player.powerUp & powerFire)						{							tempMonster->hitPoints -= 2;						#ifndef DEMO							if ((tempMonster->subKind == theProtectedMonsterNumber) && (theWorldType == typeMonster))							{								theGlobals.gScore -= 400;								if (theGlobals.gScore < 0) theGlobals.gScore = 0;								PlayASound(sndApeHit);							}							else							{								theGlobals.gScore += 40 * player.gPointsMultiplier;								PlayASound(sndPowerBananaHits);							}						#else							theGlobals.gScore += 40 * player.gPointsMultiplier;						#endif														DrawScore();						}						else						{							tempMonster->hitPoints--;						#ifndef DEMO							if ((tempMonster->subKind == theProtectedMonsterNumber) && (theWorldType == typeMonster))							{															theGlobals.gScore -= 200;								if (theGlobals.gScore < 0) theGlobals.gScore = 0;								PlayASound(sndApeHit);							}							else							{								theGlobals.gScore += 20 * player.gPointsMultiplier;								PlayASound(sndBananaHits);							}						#else							theGlobals.gScore += 20 * player.gPointsMultiplier;						#endif													DrawScore();						}						if (tempMonster->hitPoints < 1)						{					#ifndef DEMO							if ((tempMonster->subKind == theProtectedMonsterNumber) && (theWorldType == typeMonster))							{								theGlobals.gScore -= 5000;								if (theGlobals.gScore < 0) theGlobals.gScore = 0;								PlayASound(sndApeDie);							}							else							{								PlayASound(sndMonsterDestroyed);								theGlobals.gScore += 100 * player.gPointsMultiplier;							}					#else							theGlobals.gScore += 100 * player.gPointsMultiplier;					#endif													AllocateItemFromMonster(tempMonster);							CreateParticlesFromMonster(tempMonster);						#ifndef DEMO							if ((theWorldType == typeMonster) && (tempMonster->subKind == theUniqueMonsterNumber))	DrawTheMap();						#endif							DrawScore();							DisposeMonster(tempMonster);						}					}					else					{						// invincible sprite, so just destroy the banana												tempBanana->bananaStatus = 25;					}										while  (tempMonster->nextSprite != nil) tempMonster = tempMonster->nextSprite; // only register one collision per frame				}			}			tempMonster = tempMonster->nextSprite;		}				tempBanana = tempBanana->nextSprite;	}}// check thorougly if the player is overlapping with another spriteBoolean	CheckPlayerCollision(CollisionSpritePtr theSprite){	Boolean	collided;		// is it in the same room ?		if (theSprite->needToDraw == false) return 0;	// not on the visible part of the screen													// so can't collide with Darwin	if (player.theRect.top < theSprite->theRect.top) collided = CheckSpriteCollision((CollisionSpritePtr)&player, theSprite);	else collided = CheckSpriteCollision(theSprite, (CollisionSpritePtr)&player);	return collided;}// if playerMonster is true, need to check if the sprite is invertedBoolean CheckSpriteCollision(CollisionSpritePtr topSprite, CollisionSpritePtr bottomSprite){	Rect	intersect;	short	collisionHeight, collisionWidth;	short	insetV;	short	topInsetH, bottomInsetH;	Boolean	collided, overlap;	overlap = SectRect(&(topSprite->theRect), &(bottomSprite->theRect), &intersect);	if (!overlap) return false;		collided = false;	collisionHeight = intersect.bottom - intersect.top;	collisionWidth = intersect.right - intersect.left;	insetV = intersect.top - topSprite->theRect.top;		if (intersect.left == topSprite->theRect.left)	{		// bottomSprite is to the left			topInsetH = 0;		bottomInsetH = intersect.left - bottomSprite->theRect.left;	}	else	{		// topSprite is to the left				bottomInsetH = 0;		topInsetH = intersect.left - topSprite->theRect.left;	}		if (topSprite->directionFacing == directionLeft)	{		// need to flip the first sprite				if (bottomSprite->directionFacing == directionLeft)		{			// also need to flip the second sprite			topInsetH = (topSprite->theRect.right - topSprite->theRect.left) - (topInsetH + collisionWidth);			bottomInsetH = (bottomSprite->theRect.right - bottomSprite->theRect.left) - (bottomInsetH + collisionWidth);			collided = CollisionBlit(topSprite->source + (insetV * (topSprite->sourceRowBytes/2)) + topInsetH, topSprite->sourceRowBytes,							bottomSprite->source + bottomInsetH, bottomSprite->sourceRowBytes, collisionHeight, collisionWidth);				}		else		{			topInsetH = (topSprite->theRect.right - topSprite->theRect.left) - (topInsetH + collisionWidth);			collided = CollisionBlitFlip(topSprite->source + (insetV * (topSprite->sourceRowBytes/2)) + topInsetH, topSprite->sourceRowBytes,							bottomSprite->source + bottomInsetH, bottomSprite->sourceRowBytes, collisionHeight, collisionWidth);		}	}	else if (bottomSprite->directionFacing == directionLeft)	{		// just need to flip the bottom sprite				bottomInsetH = (bottomSprite->theRect.right - bottomSprite->theRect.left) - (bottomInsetH + collisionWidth);		collided = CollisionBlitFlip(topSprite->source + (insetV * (topSprite->sourceRowBytes/2)) + topInsetH, topSprite->sourceRowBytes,							bottomSprite->source + bottomInsetH, bottomSprite->sourceRowBytes, collisionHeight, collisionWidth);	}	else collided = CollisionBlit(topSprite->source + (insetV * (topSprite->sourceRowBytes/2)) + topInsetH, topSprite->sourceRowBytes,							bottomSprite->source + bottomInsetH, bottomSprite->sourceRowBytes, collisionHeight, collisionWidth);		return collided;}// check thorougly if a banana is overlapping with another spriteBoolean	CheckBananaCollision(CollisionSpritePtr theBanana, CollisionSpritePtr theSprite){	Boolean	collided;		// is it in the same room ?		if (theSprite->needToDraw == false) return 0;	// not on the visible part of the screen	// TODO - need to check banana collisions for sprites which are off screen ???	if (theBanana->theRect.top < theSprite->theRect.top) collided = CheckSpriteCollision(theBanana, theSprite);	else collided = CheckSpriteCollision(theSprite, theBanana);		return (collided);}// check thorougly if Darwin is in the doorBoolean	CheckDoorCollision(DoorSpritePtr whichDoor){	short centreDoor, centrePlayer, doorBottom;	if (whichDoor->room != theGlobals.theRoom) return false;		if (whichDoor->subKind > 1) return false;	// doors which keys open	centreDoor = whichDoor->theRect.left + (whichDoor->theRect.right - whichDoor->theRect.left)/2;	centrePlayer = player.theRect.left + 32;	doorBottom = whichDoor->theRect.bottom;		if (whichDoor->subKind == 0)	{		if ((doorBottom == (player.theRect.bottom + 6)) && (abs(centreDoor - centrePlayer) < 2)) return true;		else return false;	}	else	{		if ((abs(player.theRect.bottom - doorBottom) < 2) && (abs(centreDoor - centrePlayer) < 2))	return true;		else return false;	}}Boolean	CollisionBlit(short *source1, long offset1, short *source2, long offset2, short height, short width){	short tempWidth;		offset1 >>= 1;	offset2 >>= 1;	// run through the sprite masks looking for places where both are zero	while (height--)	{		tempWidth = width;			while (tempWidth--)		{			// the range of tempWidth inside here is 0 to width-1			if ((source1[tempWidth] != 32767) && (source2[tempWidth] != 32767)) return true;		}				source1 += offset1;		source2 += offset2;	}	return false;}Boolean	CollisionBlitFlip(short *source1, long offset1, short *source2, long offset2, short height, short width){	short tempWidth;		offset1 >>= 1;	offset2 >>= 1;	// run through the sprite masks looking for places where both are zero	while (height--)	{		tempWidth = width;			while (tempWidth--)		{			if ((source1[tempWidth] != 32767) && (source2[width - (tempWidth + 1)] != 32767)) return true;		}				source1 += offset1;		source2 += offset2;	}	return false;}void	HandleTalismanCollision(TalismanSpritePtr	theTalisman){	// turn the talisman into a points	theGlobals.gScore += 100 * player.gPointsMultiplier;	DrawScore();		BitSet(&talismanBitField, 15 - theTalisman->subKind);	if (player.gPointsMultiplier == 4) theTalisman->subKind = 18;		// 400	else if (player.gPointsMultiplier == 2) theTalisman->subKind = 17; // 200	else theTalisman->subKind = 16; // 100		theTalisman->frame = 0;	theTalisman->iconRow = theTalisman->subKind * 48;	if ((theTalisman == firstTalisman) && (theTalisman->nextSprite == nil))	{		#ifdef DEMO					#else			DoorSpritePtr	tempDoor;						// activate the exit door						tempDoor = firstDoor;						while (tempDoor)			{				if ((tempDoor->kind == maskDoorInactive) && (tempDoor->doorNumber == 1000))				{					// the exit door									tempDoor->frame = 15;					tempDoor->frameDirection = -1;					tempDoor->kind = maskDoor;				}								tempDoor = tempDoor->nextSprite;			}					PlayASound(sndObjectLastTalisman);	// must only be one left		#endif	}	else PlayASound(sndObjectTalisman);	DrawTheMap();}void	HandleItemCollision(ItemSpritePtr theItem){	short itemType = theItem->subKind;	if (itemType == itemCherry)	// fruit	{		theGlobals.gScore += 100 * player.gPointsMultiplier;		DrawScore();				if (player.gPointsMultiplier == 4) theItem->subKind = 18;		// 400		else if (player.gPointsMultiplier == 2) theItem->subKind = 17; // 200		else theItem->subKind = 16; // 100				theItem->frame = 0;		theItem->iconRow = theItem->subKind * 48;						PlayASound(sndObjectFruit);	}	else if (itemType == itemDouble)	{		// double points				player.powerUp = doublePoints | (player.powerUp & (beanieHat + fastFire + powerFire + multipleFire + shield + jetPack));	// get rid of other multipliers																										// but keep the rest		player.gPointsMultiplier = 2;		PlayASound(sndObjectMultiplier);		player.multiplierTimer += 150;		DisposeItem(theItem);	}	else if (itemType == itemQuad)	{		// quadruple points				player.powerUp = quadPoints | (player.powerUp & ( beanieHat + fastFire + powerFire + multipleFire + shield + jetPack));	// get rid of other multipliers																										// but keep the rest		player.gPointsMultiplier = 4;		PlayASound(sndObjectMultiplier);		player.multiplierTimer += 150;		DisposeItem(theItem);	}	else if (itemType == itemBeanie)	{		player.powerUp = beanieHat | (player.powerUp & (doublePoints + quadPoints + fastFire + powerFire + multipleFire + shield));	// get rid of other banana power ups		PlayASound(sndObjectBeanie);		BeanieSound();		player.beanieTimer += 150;		if (player.beanieTimer > 375) player.beanieTimer = 375;		player.jetPackTimer = 0;		theItem->kind = maskItemInactive;	// will regenerate		theItem->regenerateCountdown = 300;	// 10 seconds		theItem->needToDraw = false;	}	else if (itemType == itemBanana)	{		// some bananas#ifndef DEMO		if (theGlobals.difficulty == 0) player.numberOfBananas += 30;		else player.numberOfBananas += 20;#else		player.numberOfBananas += 20;#endif		if (player.numberOfBananas > 99) player.numberOfBananas = 99;		PlayASound(sndObjectBanana);		DrawKeyBananaStatus();		#ifndef DEMO			if (theWorldType == typeMonster)			{				theItem->kind = maskItemInactive;	// will regenerate				theItem->regenerateCountdown = 600;	// 10 seconds				theItem->needToDraw = false;			}			else DisposeItem(theItem);		#else			DisposeItem(theItem);		#endif			}	else if (itemType == itemFastFire)	{		// rapid fire		player.powerUp = fastFire | (player.powerUp & (doublePoints + quadPoints + beanieHat + shield + jetPack));	// get rid of other banana power ups																										// but keep the rest#ifndef DEMO		if (theGlobals.difficulty == 0) player.fastFireTimer += 200;		else player.fastFireTimer += 150;#else		player.fastFireTimer += 150;#endif		player.powerFireTimer = 0;		player.multipleFireTimer = 0;		player.numberOfBananas += 10;		if (player.numberOfBananas > 99) player.numberOfBananas = 99;		PlayASound(sndObjectBanana);		DrawKeyBananaStatus();		DisposeItem(theItem);	}	else if (itemType == itemPowerFire)	{		// power fire				player.powerUp = powerFire | (player.powerUp & (doublePoints + quadPoints + beanieHat + shield + jetPack));	// get rid of other banana power ups																										// but keep the rest#ifndef DEMO		if (theGlobals.difficulty == 0) player.powerFireTimer += 200;		else player.powerFireTimer += 150;#else		player.powerFireTimer += 150;#endif		player.fastFireTimer = 0;		player.multipleFireTimer = 0;		player.numberOfBananas += 10;		if (player.numberOfBananas > 99) player.numberOfBananas = 99;		PlayASound(sndObjectBanana);		DrawKeyBananaStatus();			DisposeItem(theItem);	}	else if (itemType == itemMultipleFire)	{		// multiple fire				player.powerUp = multipleFire | (player.powerUp & (doublePoints + quadPoints + beanieHat + shield + jetPack));	// get rid of other banana power ups																										// but keep the rest#ifndef DEMO		if (theGlobals.difficulty == 0) player.multipleFireTimer += 200;		else player.multipleFireTimer += 150;#else		player.multipleFireTimer += 150;#endif		player.fastFireTimer = 0;		player.powerFireTimer = 0;		player.numberOfBananas += 10;		if (player.numberOfBananas > 99) player.numberOfBananas = 99;		PlayASound(sndObjectBanana);		DrawKeyBananaStatus();			DisposeItem(theItem);	}	else if (itemType == itemExtraLife)	{		// extra life			theGlobals.gLivesLeft++; DrawLivesLeft();		PlayASound(sndObjectLife);		DisposeItem(theItem);	}	else if (itemType == itemHealth)	{		// energy		#ifndef DEMO		if (theGlobals.difficulty == 0) player.gDarwinLife += 30;		else player.gDarwinLife += 20;#else		player.gDarwinLife += 20;#endif		PlayASound(sndObjectHealth);		if (player.gDarwinLife > 171) player.gDarwinLife = 171;// player.maxLife;		DrawLifeBar();		DisposeItem(theItem);	}	else if (itemType == itemShield)	{		// shield			player.powerUp = player.powerUp | shield;#ifndef DEMO		if (theGlobals.difficulty == 0) player.shieldTimer += 200;		else player.shieldTimer += 150;#else		player.shieldTimer += 150;#endif		PlayASound(sndObjectShield);				theItem->kind = maskItemInactive;		theItem->regenerateCountdown = 300;	// 10 seconds		theItem->needToDraw = false;	}	else if (itemType < itemJetPack)		// the keys	{		if (player.key > 0)		{			// player already has a key, so swap them			if (theItem->darwinOverlapping)			{				// Darwin is still overlapping the sprite, so don't swap												}			else			{				short temp = player.key;								player.key = theItem->subKind - 10;								theItem->subKind = temp + 10;				theItem->iconRow = theItem->subKind * 48;				theItem->darwinOverlapping = true;				PlayASound(sndObjectKey);			}		}		else		{			// grab the key and dispose of the sprite						player.key = theItem->subKind - 10;						PlayASound(sndObjectKey);			DisposeItem(theItem);		}		DrawKeyBananaStatus();	}	else if (itemType == itemJetPack)	{		short	ignore, temp;		Rect	testRect;			// jet pack				player.powerUp = jetPack | (player.powerUp & (doublePoints + quadPoints + fastFire + powerFire + multipleFire + shield));		player.beanieTimer = 0;		player.jetPackTimer += 150;				if (player.jetPackTimer > 375) player.jetPackTimer = 375;				player.speedv = 0;		PlayASound(sndObjectJetPack);		JetPackSound();				SetRect(&testRect, player.theRect.left + 16, player.theRect.top, player.theRect.left + 48, player.theRect.bottom);		ignore = TestMoveSpriteDown(&testRect, 1, &temp);				if (temp == 0)		{			player.theRect.top -= 2;	// force Darwin 2 pixels off the platform			scrollOffsetV -= 2;//(player.theRect.top - temp);			player.theRect.bottom = player.theRect.top + darwinHeight;			}				theItem->kind = maskItemInactive;	// will regenerate		theItem->regenerateCountdown = 300;	// 10 seconds		theItem->needToDraw = false;	}}