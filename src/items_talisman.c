#include	"globals extern.h"void	AllocateItemFromMonster(MonsterSpritePtr	theMonster){	short			randomShort, itemType;	ItemSpritePtr	theItem;	randomShort = abs(Random());	// 0 - 32767	if (randomShort > 9500) return;	// don't always generate a power-up		// 10 different power ups, but extra life should be less likely		// x2, x4, shield, health, extra life, bananas, power bananas, multiple bananas, fast fire	if (randomShort > 9000) itemType = itemExtraLife;	else	{		itemType = randomShort / 1000; // 0 - 8		if (itemType > itemQuad) itemType++;	// skip beanie		if (itemType > itemPowerFire) itemType++;	// skip extra life	}	theItem  = AllocateItem();	theItem->room = theGlobals.theRoom;	theItem->theRect.left = (theMonster->theRect.left + theMonster->theRect.right)/2 - 24;	theItem->theRect.top = (theMonster->theRect.top + theMonster->theRect.bottom)/2 - 24;	theItem->theRect.right = theItem->theRect.left + 48;	theItem->theRect.bottom = theItem->theRect.top + 48;	theItem->subKind = itemType & 15;						// between 0 and 15	theItem->iconRow = theItem->subKind * 48;	theItem->needToDraw = false;	theItem->kind = maskItem;	theItem->sourceRowBytes = theGWorlds.itemRowOffSet;}ItemSpritePtr AllocateItem(void){	ItemSpritePtr	tempSprite, temp;		tempSprite = (ItemSpritePtr)NewPtrClear(sizeof(ItemSprite));	if (tempSprite == nil) FatalError("Sprite Allocation Failed", true);	if (firstItem == nil) firstItem = tempSprite;	else	{		// find the last item in the list				temp = firstItem;			while (temp->nextSprite != nil) temp = temp->nextSprite;			temp->nextSprite = tempSprite;		tempSprite->prevSprite = temp;	}	return tempSprite;}ItemSpritePtr DisposeItem(ItemSpritePtr theSprite){	ItemSpritePtr	returnValue;	ItemSpritePtr	tempSprite = theSprite;	if (theSprite == nil) FatalError("Trying to dispose of zero sprite", true);	returnValue = theSprite->nextSprite;		if (theSprite->nextSprite == nil)	// must be the last talisman in the list	{		if (theSprite == firstItem) firstItem = nil;	}	else if (theSprite == firstItem)	{		firstItem = theSprite->nextSprite;	}	if (tempSprite->nextSprite) (tempSprite->nextSprite)->prevSprite = tempSprite->prevSprite;	if (tempSprite->prevSprite) (tempSprite->prevSprite)->nextSprite = tempSprite->nextSprite;	DisposePtr( (Ptr)theSprite);	return returnValue;}void	HandleItems(Rect *drawingRect){	ItemSpritePtr tempItem = firstItem;		while (tempItem)	{		if (tempItem->kind != maskItemInactive) HandleOneItem(tempItem, drawingRect);		else		{			tempItem->regenerateCountdown--;						if (tempItem->regenerateCountdown == 0)			{				tempItem->kind = maskItem;			// regenerate it				HandleOneItem(tempItem, drawingRect);			}		}		tempItem = tempItem->nextSprite;	}}/* handle the items which darwin collects */void HandleOneItem(ItemSpritePtr theItem, Rect *drawingRect){	Rect	dummy;	short	insetH, insetV, h, v;		if (theItem->subKind > 15)	// points from grabbed item	{		if (theItem->frame == 7) theItem->kind = kSpriteDone;	}		if (frameCount & 1) theItem->frame = (++theItem->frame) % 8;		// is it on the visible part of the screen ?	if (theItem->room != theGlobals.theRoom) theItem->needToDraw = false;	else if (SectRect(drawingRect, &theItem->theRect, &dummy)) theItem->needToDraw = true;	else theItem->needToDraw = false;	// if we don't need to draw it, nothing more to do		if (theItem->needToDraw == false) return;		insetH = 0;	insetV = 0;	theItem->drawingHeight = dummy.bottom - dummy.top;	theItem->drawingWidth = dummy.right - dummy.left;		if (theItem->drawingWidth != (theItem->theRect.right - theItem->theRect.left))	{		// need to clip horizontally			if (theItem->theRect.left < drawingRect->left) insetH = drawingRect->left - theItem->theRect.left;	}		if (theItem->drawingHeight != (theItem->theRect.bottom - theItem->theRect.top))	{		// need to clip  vertically			if (theItem->theRect.top < drawingRect->top) insetV = drawingRect->top - theItem->theRect.top;	}		h = insetH + theItem->theRect.left - (24 * minActualHoriz);	v = insetV + theItem->theRect.top - (24 * minActualVert);	theItem->source = (short *)(theGWorlds.itemMemPtr + 2 * ((48 * theItem->frame) + insetH) + ((theItem->iconRow + insetV) * theGWorlds.itemRowOffSet));	theItem->dest = (short *)(theGWorlds.safeMemPtr + (v * theGWorlds.safeRowOffSet) + 2 * h);}TalismanSpritePtr AllocateTalisman(void){	TalismanSpritePtr	tempSprite, temp;		tempSprite = (TalismanSpritePtr)NewPtrClear(sizeof(TalismanSprite));	if (tempSprite == nil) FatalError("Sprite Allocation Failed", true);	if (firstTalisman == nil) firstTalisman = tempSprite;	else	{		// find the last hazard in the list				temp = firstTalisman;			while (temp->nextSprite != nil) temp = temp->nextSprite;			temp->nextSprite = tempSprite;		tempSprite->prevSprite = temp;	}	return tempSprite;}TalismanSpritePtr DisposeTalisman(TalismanSpritePtr theSprite){	TalismanSpritePtr	returnValue;	TalismanSpritePtr	tempSprite = theSprite;	if (theSprite == nil) FatalError("Trying to dispose of zero sprite", true);	returnValue = theSprite->nextSprite;		if (theSprite->nextSprite == nil)	// must be the last talisman in the list	{		if (theSprite == firstTalisman) firstTalisman = nil;	}	else if (theSprite == firstTalisman)	{		firstTalisman = theSprite->nextSprite;	}	if (tempSprite->nextSprite) (tempSprite->nextSprite)->prevSprite = tempSprite->prevSprite;	if (tempSprite->prevSprite) (tempSprite->prevSprite)->nextSprite = tempSprite->nextSprite;	DisposePtr( (Ptr)theSprite);	return returnValue;}// TODO - temporary measure - talisman differentvoid	HandleTalisman(Rect *drawingRect){	TalismanSpritePtr tempTalisman = firstTalisman;		while (tempTalisman)	{		HandleOneTalisman(tempTalisman, drawingRect);		tempTalisman = tempTalisman->nextSprite;	}}void HandleOneTalisman(TalismanSpritePtr theTalisman, Rect *drawingRect){	Rect	dummy;	short	insetH, insetV, h, v;		if (theTalisman->subKind > 15)	// points from grabbed item	{		if (theTalisman->frame == 7) theTalisman->kind = kSpriteDone;	}		if (frameCount & 1) theTalisman->frame = (++theTalisman->frame) % 8;		// is it on the visible part of the screen ?	if (theTalisman->room != theGlobals.theRoom) theTalisman->needToDraw = false;	else if (SectRect(drawingRect, &theTalisman->theRect, &dummy)) theTalisman->needToDraw = true;	else theTalisman->needToDraw = false;	// if we don't need to draw it, nothing more to do		if (theTalisman->needToDraw == false) return;		insetH = 0;	insetV = 0;	theTalisman->drawingHeight = dummy.bottom - dummy.top;	theTalisman->drawingWidth = dummy.right - dummy.left;		if (theTalisman->drawingWidth != (theTalisman->theRect.right - theTalisman->theRect.left))	{		// need to clip horizontally			if (theTalisman->theRect.left < drawingRect->left) insetH = drawingRect->left - theTalisman->theRect.left;	}		if (theTalisman->drawingHeight != (theTalisman->theRect.bottom - theTalisman->theRect.top))	{		// need to clip  vertically			if (theTalisman->theRect.top < drawingRect->top) insetV = drawingRect->top - theTalisman->theRect.top;	}		h = insetH + theTalisman->theRect.left - (24 * minActualHoriz);	v = insetV + theTalisman->theRect.top - (24 * minActualVert);	theTalisman->source = (short *)(theGWorlds.itemMemPtr + 2 * ((48 * theTalisman->frame) + insetH) + ((theTalisman->iconRow + insetV) * theGWorlds.itemRowOffSet));	theTalisman->dest = (short *)(theGWorlds.safeMemPtr + (v * theGWorlds.safeRowOffSet) + 2 * h);}void	StoreKeyCopies(void){	ItemSpritePtr	tempItem, tempKey;		if (firstKeyCopy != nil)	{		// dispose of previous ones			tempItem = firstKeyCopy;		while (tempItem) tempItem = DisposeKeyCopy(tempItem);		}			tempItem = firstItem;		while (tempItem)	{		if ((tempItem->subKind >= itemRedKey) && (tempItem->subKind <= itemBlueKey))		{			ItemSpritePtr	tempLink1, tempLink2;						tempKey = AllocateKeyCopy();						tempLink1 = tempKey->prevSprite;			tempLink2 = tempKey->nextSprite;						BlockMoveData(tempItem, tempKey, sizeof(ItemSprite));						tempKey->prevSprite = tempLink1;			tempKey->nextSprite = tempLink2;		}				tempItem = tempItem->nextSprite;	}}void	RestoreKeyCopies(void){	ItemSpritePtr	tempItem, tempKey;	// first need to dispose of the existing keys		tempItem = firstItem;	while (tempItem)	{		if ((tempItem->subKind >= itemRedKey) && (tempItem->subKind <= itemBlueKey))		{			tempItem = DisposeItem(tempItem);		}		else tempItem = tempItem->nextSprite;	}		// now allocate items and copy back the data		tempKey = firstKeyCopy;		while (tempKey)	{		ItemSpritePtr	tempLink1, tempLink2;		tempItem = AllocateItem();		tempLink1 = tempItem->prevSprite;		tempLink2 = tempItem->nextSprite;				BlockMoveData(tempKey, tempItem, sizeof(ItemSprite));			tempItem->prevSprite = tempLink1;		tempItem->nextSprite = tempLink2;			tempKey = tempKey->nextSprite;	}}ItemSpritePtr AllocateKeyCopy(void){	ItemSpritePtr	tempSprite, temp;		tempSprite = (ItemSpritePtr)NewPtrClear(sizeof(ItemSprite));	if (tempSprite == nil) FatalError("Sprite Allocation Failed", true);	if (firstKeyCopy == nil) firstKeyCopy = tempSprite;	else	{		// find the last item in the list				temp = firstKeyCopy;			while (temp->nextSprite != nil) temp = temp->nextSprite;			temp->nextSprite = tempSprite;		tempSprite->prevSprite = temp;	}	return tempSprite;}ItemSpritePtr DisposeKeyCopy(ItemSpritePtr theSprite){	ItemSpritePtr	returnValue;	ItemSpritePtr	tempSprite = theSprite;	if (theSprite == nil) FatalError("Trying to dispose of zero sprite", true);	returnValue = theSprite->nextSprite;		if (theSprite->nextSprite == nil)	// must be the last talisman in the list	{		if (theSprite == firstKeyCopy) firstKeyCopy = nil;	}	else if (theSprite == firstKeyCopy)	{		firstKeyCopy = theSprite->nextSprite;	}	if (tempSprite->nextSprite) (tempSprite->nextSprite)->prevSprite = tempSprite->prevSprite;	if (tempSprite->prevSprite) (tempSprite->prevSprite)->nextSprite = tempSprite->nextSprite;	DisposePtr( (Ptr)theSprite);	return returnValue;}