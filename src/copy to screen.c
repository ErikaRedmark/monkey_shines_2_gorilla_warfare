#include "globals extern.h"#include	<ctype.h>/* The GWorld is big enough for one full platform in each direction, plus the size of thelargest sprite in each direction.If we make sure the top left of the platform in this GWorld is the size of this spriteit should be easier to work out what should be drawn.We will know where the old minimum was.*/#ifdef useProfiler#pragma profile on#endifvoid	PreCalculateVisibleRect(Rect	*needToDraw){	short	left, top, right, bottom;		// put Darwin at 252, 144 (middle of a 576 x 360 GWorld) - i.e. this visible part of the screen		// then make sure the game doesn't scroll past the edge of the world	left = player.theRect.left - (scrollOffsetH + 252);	top = player.theRect.top - (scrollOffsetV + 144);		#ifdef DEMO		if (hackedFour) FatalError("Play Area Out of Bounds", true);	#endif		// optimisation of//	left = player.theRect.left - ((screenWidthPixels/2) - (darwinWidth/2)) - scrollOffsetH;//	top = player.theRect.top - ((screenHeightPixels/2) - (darwinWidth/2)) - scrollOffsetV;		if (left < 0)	{		scrollOffsetH += left;		left = 0;	}		if (top < 0)	{		scrollOffsetV += top;		top = 0;		}		right = player.theRect.left + 324 - scrollOffsetH;	bottom = player.theRect.top + 216 - scrollOffsetV;	// optimisation of//	right = player.theRect.left + ((screenWidthPixels/2) + (darwinWidth/2)) - scrollOffsetH;//	bottom = player.theRect.top + ((screenHeightPixels/2) + (darwinWidth/2)) - scrollOffsetV;		if (right > (roomWidthPixels - 1))	{		scrollOffsetH += (right + 1 - roomWidthPixels);		right = roomWidthPixels - 1;		left = right - 576;	}	if (bottom > (roomHeightPixels - 1))	{		scrollOffsetV += (bottom + 1 - roomHeightPixels);		bottom = roomHeightPixels - 1;		top = bottom - 360;	}		SetRect (needToDraw, left, top, right, bottom);		// work out which whole platforms need to be drawn so that we actually have the bits we need			minRequiredVert = needToDraw->top / 24;	minRequiredHoriz = needToDraw->left / 24;	maxRequiredVert = needToDraw->bottom / 24;	maxRequiredHoriz = needToDraw->right / 24;}#ifndef DEMOvoid CheckRegistrationThree( void ){	long		nameNumber, regcode;	Str255		nameText;	short t,tt;	long		temp;	int worldswitch[2][8] = {	   							1,4,5,11,18,21,24,27,	   							2,3,8,14,17,23,27,29	   						};   		// need to check for blacklisted registration codes	if (((**gPrefs).registerName[0] < 1) || ((**gPrefs).registerName[1] == ' '))	{		// invalid string					CopyString((**gPrefs).registerName, "\pYour name");			(**gPrefs).registrationCode = 0;			gRegistered = 0;			// write out the modified preferences to disk									UpdatePreferences();			return;	}	else if ((**gPrefs).registerName[0] > 31) (**gPrefs).registerName[0] = 31;	 	StringToNum((**gPrefs).registerName, &nameNumber);	CopyString(nameText, (**gPrefs).registerName);	nameNumber &= 0x7FFFFFFF;	regcode = (**serialNumberHandle).serialNumber + nameNumber;	for(t = 1;t <= nameText[0];t++)	/************* do bitswitch for name *************/	{		if (nameText[t] == 0) goto pushon;		nameText[t] = tolower(nameText[t]);		if (nameText[t] == 32) nameText[t] = 128;		temp = nameText[t]-97;		if (BitTst(&regcode,temp)) BitClr(&regcode,temp);		else BitSet(&regcode,temp);	}	 	pushon:	 		for(tt=0;tt<8;tt++) 	{			   		if (BitTst(&regcode,worldswitch[1][tt])) BitClr(&regcode,worldswitch[1][tt]);		else BitSet(&regcode,worldswitch[1][tt]);	}	regcode &= 0x7FFFFFFF;	if ((**gPrefs).registrationCode == regcode) gRegistered = 135;	else 	{		CopyString((**gPrefs).registerName, "\pYour name");		(**gPrefs).registrationCode = 0;		gRegistered = 0;		// write out the modified preferences to disk							UpdatePreferences();	}}#endif/*	We know what we need to draw, and what was drawn, so decide if we need to swap GWorlds,	and if so, just do it		Since Darwin is at 264, 156 + largestSprite, we can work out WHERE it needs to be drawn*/void	LoadDisposeRowColumn(void){	short loop;	if (minRequiredHoriz < minActualHoriz)	{		// need to draw a bit to the left				for (loop = minRequiredHoriz; loop < minActualHoriz; loop++) DrawOneColumn(loop);		for (loop = maxRequiredHoriz + 1; loop <= maxActualHoriz; loop++) DisposeOneColumn(loop);	}	else if (maxRequiredHoriz > maxActualHoriz)	{		// need to draw a bit to the right		for (loop = maxActualHoriz + 1; loop <= maxRequiredHoriz; loop++) DrawOneColumn(loop);		for (loop = minActualHoriz; loop < minRequiredHoriz; loop++) DisposeOneColumn(loop);	}	if (minRequiredVert < minActualVert)	{		// need to draw a bit to the top		for (loop = minRequiredVert; loop < minActualVert; loop++) DrawOneRow(loop);		for (loop = maxRequiredVert + 1; loop <= maxActualVert; loop++) DisposeOneRow(loop);	}	else if (maxRequiredVert > maxActualVert)	{		// need to draw a bit to the bottom		for (loop = maxActualVert + 1; loop <= maxRequiredVert; loop++) DrawOneRow(loop);		for (loop = minActualVert; loop < minRequiredVert; loop++) DisposeOneRow(loop);	}		minActualHoriz = minRequiredHoriz;	minActualVert = minRequiredVert;	maxActualHoriz = maxRequiredHoriz;	maxActualVert = maxRequiredVert;}#ifdef useProfiler#pragma profile off#endif