/*Copyright (C) 1996-1997 Id Software, Inc.This program is free software; you can redistribute it and/ormodify it under the terms of the GNU General Public Licenseas published by the Free Software Foundation; either version 2of the License, or (at your option) any later version.This program is distributed in the hope that it will be useful,but WITHOUT ANY WARRANTY; without even the implied warranty ofMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.You should have received a copy of the GNU General Public Licensealong with this program; if not, write to the Free SoftwareFoundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.*/#include "globals extern.h"																			//#include "quakedef.h"#include <DriverGestalt.h>#include <Devices.h>#include <ToolUtils.h>#include <String.h>//¥	Audio playback modes#define playmodeMute				0x00#define playmodeRightOnly			0x05#define playmodeStereo				0x09#define playmodeLeftOnly			0x0A#define playmodeMono				0x0Ftypedef struct{	unsigned char control;	unsigned char track;	unsigned char PMIN;	unsigned char PSEC;	unsigned char PFRAME;} TOCEntry;#define MAX_AUDIO_CD 16typedef struct{	UInt8 firstAudioTrack;	UInt8 lastAudioTrack;	char name[256];	short driverRefNum;	UInt8 volume;	UInt8 track;} AudioCDStruct;enum{	csDriveStatus				=	8,	csReadTOC					=	100,	csReadQ						=	101,	csAudioTrackSearch			=	103,	csAudioPlay					=	104,	csAudioPause				=	105,	csAudioStop					=	106,	csAudioStatus				=	107,	csAudioVolume				=	109,	csGetSpindleSpeed			=	113};enum{	addressLBS,	addressMIN_SEC_FRAME,	addressTrack};//// Global prototypes//OSErr InitialiseCDAudio (void);void CDAudio_Volume (UInt8 vol);void CDAudio_Play (Byte track, Boolean looping);void CDAudio_Stop (void);void CDAudio_Play (Byte track, Boolean looping);//// Local prototypes//static void CDAudio_StopCD (UInt8 whichCD);static void CDAudio_ReadTOC (short driverRef, AudioCDStruct *thisCD);static UInt32 NumToBCD (UInt16 theNum);static SInt16 BCDToNum (UInt8 bcd);//// Local variables//static AudioCDStruct sAudioCD[MAX_AUDIO_CD];static UInt8 sTotalCDs;static UInt8 sCurrentCD;static ParamBlockRec sPlayParamBlock;static ParamBlockRec sStopParamBlock;static short isplaying;static void CopyPascalStringToC(ConstStr255Param src, char* dst){	if ( src != NULL )	{		short   length  = *src++;			while ( length > 0 ) 		{			*dst++ = *(char*)src++;			--length;		}	}	*dst = '\0';}//// Implementation//OSErr InitialiseCDAudio (void){	HVolumeParam *pb;	Str255 ioName;	OSErr theErr;	int i;//	Sys_Printf("Searching for audio CDs...\n");	sTotalCDs = 0;	sCurrentCD = 0;	isplaying = 0;	// Find an audio CD volume.	pb = (HVolumeParam *)NewPtrClear(sizeof(*pb));	theErr = MemError();	if ((pb != NULL) && (theErr == noErr)) 	{		Boolean done = false;			pb->ioNamePtr = ioName;		pb->ioVolIndex = 0;				do		{			pb->ioVolIndex++;			theErr = PBHGetVInfoSync ((HParmBlkPtr)pb);						if (theErr == noErr)			{				AudioCDStruct thisCD;								CDAudio_ReadTOC (pb->ioVDRefNum, &thisCD);								// If it's got Redbook data, add it to the list				if (thisCD.firstAudioTrack != 0)				{					memcpy (&sAudioCD[sTotalCDs], &thisCD, sizeof (AudioCDStruct));					CopyPascalStringToC(ioName,sAudioCD[sTotalCDs].name);					// Stop each CD we find in case it was playing beforehand					CDAudio_StopCD (sTotalCDs);					sTotalCDs ++;				}			}			else				done = true;		}		while(!done);	}	DisposePtr((Ptr)pb);		if (sTotalCDs == 0) return -100;		sCurrentCD = -99;		for (i = 0; i < sTotalCDs; i ++)	{		if (sAudioCD[i].firstAudioTrack != 0)		{			if (strcmp(sAudioCD[i].name, "Gorilla Warfare") == 0) sCurrentCD = i;		}	}		if (sCurrentCD == -99) return -99;	else return noErr;}//¥	ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ	NumToBCDstatic UInt32 NumToBCD (UInt16 theNum){	UInt32	theBCD;	theBCD = 0x0000;		//¥	Get the digits	theBCD |= theNum % 10;	theNum /= 10;	//¥	Get the tens	theBCD |= (theNum % 10) << 4;	theNum /= 10;		//¥	Get the hundreds	theBCD |= (theNum % 10) << 8;	theNum /= 10;		//¥	Get the thousands	theBCD |= (theNum % 10) << 12;		return (theBCD);}//¥	ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ	BCDToNumstatic SInt16 BCDToNum (UInt8 bcd){	UInt8	place;	SInt16	num = 0;		place = bcd & 0x0F;									//¥	Get the first 10 bits	num += place;		place = (bcd >> 4) & 0x0F;	num += (place * 10);		return (num);}#pragma mark -static void CDAudio_ReadTOC (short driverRef, AudioCDStruct *thisCD){	OSErr theErr;	ParamBlockRec thePB;	char theTOC[512];	int numTracks = 0;	TOCEntry *ptoc = NULL;#if TARGET_API_MAC_CARBON	return;#else	// clear out our structures	memset (&thePB, 0, sizeof (thePB));	memset (theTOC, 0, sizeof (theTOC));	memset (thisCD, 0, sizeof (AudioCDStruct));	// Get the entire table of contents.	thePB.cntrlParam.ioCRefNum = driverRef;		thePB.cntrlParam.csCode = csReadTOC;	thePB.cntrlParam.csParam[0] = 4;	thePB.cntrlParam.csParam[1] = HiWord(theTOC);	thePB.cntrlParam.csParam[2] = LoWord(theTOC);	theErr = PBControlSync (&thePB);		if (theErr == noErr)	{		ptoc = (TOCEntry *)&theTOC[16];				thisCD->firstAudioTrack = 1;		thisCD->driverRefNum = driverRef;		// find the first redbook track		while ((ptoc->track != 0) && (ptoc->control == 4))		{			ptoc ++;			thisCD->firstAudioTrack ++;		}				// We're at the end of the TOC, no redbook tracks		if (ptoc->track == 0)		{			thisCD->firstAudioTrack = 0;			return;		}				// Find the last redbook track		while (ptoc->track != 0)		{			numTracks ++;			ptoc++;		}		thisCD->lastAudioTrack = numTracks + thisCD->firstAudioTrack - 1;		thisCD->volume = 255;	}#endif}void CDAudio_Play (Byte track, Boolean looping){	if (sAudioCD[sCurrentCD].firstAudioTrack != 0)	{						OSErr theErr;		ParamBlockRec *thePB = &sPlayParamBlock;		FlushEvents (everyEvent, 0);		if ((track < sAudioCD[sCurrentCD].firstAudioTrack) || (track > sAudioCD[sCurrentCD].lastAudioTrack))		{	//		Con_Printf("Audio CD : Attempted to play track %d, out of range for this CD.\n", track);			CDAudio_Stop();			return;		}		memset (thePB, 0, sizeof(thePB));		thePB->cntrlParam.ioCRefNum = sAudioCD[sCurrentCD].driverRefNum;			thePB->cntrlParam.csCode = csAudioPlay;		thePB->cntrlParam.csParam[0] = addressTrack;		thePB->cntrlParam.csParam[1] = 0;		thePB->cntrlParam.csParam[2] = LoWord(NumToBCD(track));		thePB->cntrlParam.csParam[3] = 0;							// set to 1 to move to next track when done		thePB->cntrlParam.csParam[4] = playmodeStereo;			theErr = PBControlSync (thePB);			if (theErr != noErr)		{			CDAudio_Stop ();			sAudioCD[sCurrentCD].firstAudioTrack = 0;	//		Con_Printf("Audio CD : Error playing track %d , audio CD stopped\n",track);		}		else		{			sAudioCD[sCurrentCD].track = track;			isplaying = 1;						// Set the volume. Some digital drives need this (Firewire, DVD)			SetMusicVolume((**gPrefs).musicVolume);//			CDAudio_Volume (sAudioCD[sCurrentCD].volume);		}	}	else	{}//		Con_Printf("Error : audio CD not found / not inserted\n");}static void CDAudio_StopCD (UInt8 whichCD){	ParamBlockRec	*thePB = &sStopParamBlock;	OSErr theErr;	#if TARGET_API_MAC_CARBON	return;#else	if (sAudioCD[whichCD].firstAudioTrack == 0) return;	memset (thePB, 0, sizeof(thePB));	thePB->cntrlParam.ioCRefNum = sAudioCD[whichCD].driverRefNum;	thePB->cntrlParam.csCode = csAudioStop;		theErr = PBControlSync (thePB);//	Sys_Printf ("Audio CD %d (trying to stop) returned %d\n", whichCD, theErr);	isplaying = 0;	sAudioCD[whichCD].track = 0;#endif}void CDAudio_Stop (void){	ParamBlockRec	*thePB = &sStopParamBlock;	OSErr theErr;	#if TARGET_API_MAC_CARBON	return;#else	if (sAudioCD[sCurrentCD].firstAudioTrack == 0) return;	memset (thePB, 0, sizeof (thePB));	thePB->cntrlParam.ioCRefNum = sAudioCD[sCurrentCD].driverRefNum;	thePB->cntrlParam.csCode = csAudioStop;		theErr = PBControlSync (thePB);	if (theErr == noErr)	{		isplaying = 0;		sAudioCD[sCurrentCD].track = 0;	}	//	Sys_Printf ("Audio CD %d (trying to stop) returned %d\n", sCurrentCD, theErr);#endif}void CDAudio_Pause (void){	ParamBlockRec	*thePB = &sPlayParamBlock;	OSErr theErr;		if (sAudioCD[sCurrentCD].firstAudioTrack == 0) return;	if (!isplaying) return;		memset (thePB, 0, sizeof(thePB));	thePB->cntrlParam.ioCRefNum = sAudioCD[sCurrentCD].driverRefNum;	thePB->cntrlParam.csCode = csAudioPause;		theErr = PBControlSync (thePB);//	Sys_Printf("Audio CD %d (trying to pause) returned %d\n", sCurrentCD, theErr);}void CDAudio_Resume (void){	ParamBlockRec	*thePB = &sPlayParamBlock;	OSErr theErr;		if (sAudioCD[sCurrentCD].firstAudioTrack == 0) return;	if (!isplaying) return;	#if TARGET_API_MAC_CARBON	return;#else	memset (thePB, 0, sizeof(thePB));	thePB->cntrlParam.ioCRefNum = sAudioCD[sCurrentCD].driverRefNum;	thePB->cntrlParam.csCode = csAudioPause;		theErr = PBControlSync (thePB);//	Sys_Printf("Audio CD %d (trying to resume) returned %d\n", sCurrentCD, theErr);#endif}void CDAudio_Volume (UInt8 vol){	ParamBlockRec	*thePB = &sPlayParamBlock;	OSErr theErr;	UInt16 newVolume;		if (sAudioCD[sCurrentCD].firstAudioTrack == 0) return;	#if TARGET_API_MAC_CARBON	return;#else	memset (thePB, 0, sizeof(thePB));	thePB->cntrlParam.ioCRefNum = sAudioCD[sCurrentCD].driverRefNum;	thePB->cntrlParam.csCode = csAudioVolume;	// Set left/right to the same volume	newVolume = (vol << 8) | vol;	thePB->cntrlParam.csParam[0] = newVolume;		theErr = PBControlSync (thePB);//	Sys_Printf("Audio CD %d (trying to pause) returned %d\n", sCurrentCD, theErr);#endif}static void CDAudio_Eject (void){	OSErr			theErr;	Str255			ioName;	HVolumeParam	params;	short			driverRef;	if (sAudioCD[sCurrentCD].firstAudioTrack == 0) return;#if TARGET_API_MAC_CARBON	return;#else	CDAudio_Stop();	memset(&params, 0, sizeof (params));	params.ioNamePtr = ioName;	params.ioVolIndex = 0;	driverRef = sAudioCD[sCurrentCD].driverRefNum;	do	{		params.ioVolIndex++;				theErr = PBHGetVInfoSync((HParmBlkPtr) &params);		if (theErr) return;	} while (params.ioVDRefNum != driverRef);	theErr = PBUnmountVol((ParmBlkPtr) &params);	if (noErr == theErr)	{		params.ioVRefNum = params.ioVDrvInfo;		//¥	get the drive number		theErr = PBEject((ParmBlkPtr) &params);	}//	Sys_Printf("Audio CD %d (trying to eject) returned %d\n", sCurrentCD, theErr);#endif}void CDAudio_Update(void){	// We don't need to do any periodic updates}int CDAudio_Init(void){	//	Cmd_AddCommand ("cd", CD_f);//	FindAudioCDs (); //Searching for the first cdrom device	if (sTotalCDs != 0)	{				}	//	Con_Printf("Audio CD : Audio Initialized\n");	else	{		}	//	Con_Printf("Audio CD : Failed to find an audio CD - disabled\n");	return 0;}void CDAudio_Shutdown(void){	CDAudio_Stop();//	Sys_Printf ("Audio CD %d (trying to shutdown)\n", sCurrentCD);}