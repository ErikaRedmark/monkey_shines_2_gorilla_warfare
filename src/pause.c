#include	"globals extern.h"#include	<ControlStrip.h>Boolean	paused;// pause the gamevoid PauseGame( void ){	EventRecord	event;	MenuHandle menu;	PicHandle		pausedPict;	Rect			tempRect;	short			oldFile;	oldFile = CurResFile();	// suspend input sprocket	Input_Activate(true);	CustomShowCursor();	paused = true;	// draw the picture		UseResFile(theFileStuff.GWDataFileNumber);	pausedPict = GetPicture(700);	if (pausedPict == nil) FatalError("Error loading PICT 700", true);	UseResFile(theFileStuff.worldFile);	SetRect(&tempRect, 0, 0, 640, 480);	DrawPicture(pausedPict, &tempRect);	BackColor(whiteColor);		// set the music volume to zero//	StopGameMusic();	PauseGameMusic();	// allow the user access to the menu bar	ShowTheMenuBar();	// disable menu options we don't want the player to use	menu = GetMenuHandle(128);	DisableItem(menu, 1);		menu = GetMenuHandle(129);	DisableItem(menu, 1);	DisableItem(menu, 2);	DisableItem(menu, 3);	DisableItem(menu, 4);	EnableItem(menu, 7);	// resume	while (paused)	{		if (WaitNextEvent(everyEvent, &event, 20L, nil)) DoPauseEvent(&event, pausedPict);	}		ReleaseResource((Handle)pausedPict);	// enable the menus	menu = GetMenuHandle(128);	EnableItem(menu, 1);		menu = GetMenuHandle(129);	EnableItem(menu, 1);	EnableItem(menu, 2);	EnableItem(menu, 3);	EnableItem(menu, 4);	DisableItem(menu, 7);	// resume	// hide the menu bar	HideTheMenuBar();	// restore the music	ResumeGameMusic();	// now need to restore what was on the screen	CustomHideCursor();	Input_Activate(false);		DrawInterfaceBar();	UseResFile(oldFile);		justSaved = true;	// hack to stop the game catching up on dropped frames}void DoPauseEvent(EventRecord *eventPtr, PicHandle pausedPict){	char	theChar;	Rect	tempRect;			switch (eventPtr->what)	{	case keyDown:	case autoKey:		if (!theUserInterface.gInBackGround)		{			theChar = eventPtr->message & charCodeMask;			if ((eventPtr->modifiers & cmdKey) != 0)			HandlePauseMenuChoice(MenuKey(theChar));		}		break;		case mouseDown:		if (!theUserInterface.gInBackGround)	HandlePauseMouseDown(eventPtr);		break;		case updateEvt:		BeginUpdate((WindowPtr)eventPtr->message);		SetRect(&tempRect, 0, 0, 640, 480);		DrawPicture(pausedPict, &tempRect);		EndUpdate((WindowPtr)eventPtr->message);		break;			case osEvt:		HandlePauseSuspendResume(eventPtr);		break;	}}void HandlePauseSuspendResume(EventRecord *eventPtr){	if ((eventPtr->message & suspendResumeMessage) == resumeFlag)	{		// resume		if (ChangeResolution() == false) FatalError("Resolution Switch Failed", false);		theUserInterface.gInBackGround = false;		GetDefaultOutputVolume(&theAudioStuff.systemSoundVolume);		SetDefaultOutputVolume(0x01000100);		SetupWindow();		SetCCursor(theUserInterface.myCursor);		if (theUserInterface.controlStripUsed)	SBShowHideControlStrip(true);	}		else	{		theUserInterface.gInBackGround = true;		SetDefaultOutputVolume(theAudioStuff.systemSoundVolume);				CloseWindow(theUserInterface.theWindow);		if (theUserInterface.blankingWindow) CloseWindow(theUserInterface.blankingWindow);		ShowTheMenuBar();		if (theUserInterface.controlStripUsed)	SBShowHideControlStrip(false);		SetCursor(&qd.arrow);		RestoreResolution();	}}void HandlePauseMouseDown(EventRecord *eventPtr){	short thePart;	WindowPtr whichWindow;	long menuChoice;			thePart = FindWindow (eventPtr->where, &whichWindow);		switch (thePart)	{		case inMenuBar:// need to show the menu bar, draw it, then handle the menu choice// hide the menu bar and update the relevant parts of the screen			menuChoice = MenuSelect(eventPtr->where);			HandlePauseMenuChoice(menuChoice);			break;		case inSysWindow:			SystemClick(eventPtr, whichWindow);			break;	}	}void HandlePauseMenuChoice(long menuChoice){	short menu, item;	unsigned long temp;		if (menuChoice != 0)	{		menu = HiWord(menuChoice);		item = LoWord(menuChoice);				switch (menu)		{			case 100:				CheckItem(theUserInterface.soundMenu, ((**gPrefs).soundVolume) + 1, false);				(**gPrefs).soundVolume = item - 1;				SetSoundVolume((**gPrefs).soundVolume);				CheckItem(theUserInterface.soundMenu, item, true);								// write out the modified preferences to disk										UpdatePreferences();				HiliteMenu(0);				break;			case 101:				CheckItem(theUserInterface.musicMenu, ((**gPrefs).musicVolume) + 1, false);				(**gPrefs).musicVolume = item - 1;				CheckItem(theUserInterface.musicMenu, item, true);				// write out the modified preferences to disk										UpdatePreferences();				HiliteMenu(0);				break;			case 128:				HandlePauseAppleChoice(item);				break;			case 129:				switch (item)				{					case 7:						// this is "resume"						paused = false;						break;					case 8:						break;					case 9:						temp = TickCount();						GWDelay(0, 10, false);						HiliteMenu(0);						CleanUpAndQuit();						ExitToShell();						break;				}				break;					}	}}void HandlePauseAppleChoice(short item){	MenuHandle appleMenu;	Str255 accName;	short accNumber;		switch (item)	{		case 1:			// should never get here since we have disabled this item		break;					default:		appleMenu = GetMenuHandle(128);		GetMenuItemText(appleMenu, item, accName);		accNumber = OpenDeskAcc(accName);		break;	}}