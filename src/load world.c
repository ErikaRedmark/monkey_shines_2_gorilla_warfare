#include	"globals extern.h"void	LoadWorldData(void){#ifndef DEMO	WorldInfoHandle	worldInfo;#endif	// set up the particle list		firstParticle = nil;	lastParticle = nil;		// some world properties	firstMonster = nil;	firstDoor = nil;	firstTalisman = nil;	firstItem = nil;	firstKeyCopy = nil;#ifndef DEMO	worldInfo = (WorldInfoHandle)Get1Resource('wnfo', 128);	theWorldType = (**worldInfo).worldType;	theUniqueMonsterNumber = (**worldInfo).uniqueMonsterNumber;	theProtectedMonsterNumber = (**worldInfo).protectedMonsterNumber;	if ((**worldInfo).testingLevel == 194) invincible = true;	else invincible = false;	if (!gRegistered) FatalError("Can't access world data", true);#endif	LoadTheGraphics();	LoadExtraSounds();	#ifndef	DEMO	if (theFileStuff.saveFileInUse) LoadGame();#endif	// world file is current res file		LoadTheMonsters();	LoadTheDoors();	LoadTheItems();}/****************************************************************//*																*//*			load the graphics for this world					*//*																*//****************************************************************/void LoadTheGraphics( void ){	PicHandle		tempPict;	short			numberOfMonsters;	Rect			tempRect;	Boolean			allSpritesLoaded = false;			// now count the number of monsters	// easiest to do this while loading them !	/* draw monster sprites in their gworlds */	UseResFile(theFileStuff.worldFile);	numberOfMonsters = 0;	while (!allSpritesLoaded)	{		tempPict = GetPicture(1000 + numberOfMonsters);				if (tempPict)		{			SetRect(&tempRect, 0, 0, (**tempPict).picFrame.right, (**tempPict).picFrame.bottom);			NewGWorld(&theGWorlds.monsterGWorld[numberOfMonsters], 16, &tempRect, nil, nil, 0L);			theGWorlds.monsterPixMap[numberOfMonsters] = GetGWorldPixMap(theGWorlds.monsterGWorld[numberOfMonsters]);			MoveHHi((Handle)theGWorlds.monsterPixMap[numberOfMonsters]);			LockPixels(theGWorlds.monsterPixMap[numberOfMonsters]);						theGWorlds.monsterMemPtr[numberOfMonsters] = (Byte *)GetPixBaseAddr(theGWorlds.monsterPixMap[numberOfMonsters]);						SetGWorld(theGWorlds.monsterGWorld[numberOfMonsters], nil);			DrawPicture(tempPict, &tempRect);			ReleaseResource((Handle)tempPict);			numberOfMonsters++;		}		else allSpritesLoaded = true;	}		SetGWorld(theGWorlds.platformGWorld, nil);	// several pictures to be drawn here	tempPict = GetPicture(128);	if (tempPict == nil) FatalError("Error loading 128 (platforms)", true);	SetRect(&tempRect, 0, 0, 384, 192);	DrawPicture(tempPict, &tempRect);	ReleaseResource((Handle)tempPict);		// make sure the doors aren't drawn as tiles		SetRect(&tempRect, 360, 0, 384, 24);	BackColor(whiteColor);	EraseRect(&tempRect);		tempPict = GetPicture(129);	if (tempPict == nil) FatalError("Error loading PICT 129 (platforms)", true);	SetRect(&tempRect, 384, 0, 768, 192);	DrawPicture(tempPict, &tempRect);	ReleaseResource((Handle)tempPict);	// scenery	tempPict = GetPicture(130);	if (tempPict == nil) FatalError("Error loading PICT 130 (scenery)", true);	SetRect(&tempRect, 0, 192, 768, 480);	DrawPicture(tempPict, &tempRect);	ReleaseResource((Handle)tempPict);	// conveyor belts	tempPict = GetPicture(131);		if (tempPict == nil) FatalError("Error loading PICT 131 (conveyors)", true);	SetRect(&tempRect, 768, 0, 912, 192);	DrawPicture(tempPict, &tempRect);	ReleaseResource((Handle)tempPict);	theGWorlds.conveyorMemPtr = theGWorlds.platformMemPtr + 1536;		// dissolvers	tempPict = GetPicture(132);	if (tempPict == nil) FatalError("Error loading PICT 132 (dissolvers)", true);	SetRect(&tempRect, 768, 192, 960, 384);	DrawPicture(tempPict, &tempRect);	ReleaseResource((Handle)tempPict);	theGWorlds.dissolverMemPtr = theGWorlds.platformMemPtr + (192 * theGWorlds.platformRowOffSet) + 1536;	// springs		tempPict = GetPicture(136);	if (tempPict == nil) FatalError("Error loading PICT 136 (springs)", true);	SetRect(&tempRect, 960, 0, 1344, 384);	DrawPicture(tempPict, &tempRect);	ReleaseResource((Handle)tempPict);	theGWorlds.springMemPtr = theGWorlds.platformMemPtr + 1920;		// get the banana icons to flash in the interface bar from the data file		UseResFile(theFileStuff.GWDataFileNumber);	tempPict = GetPicture(130);	if (tempPict == nil) FatalError("Error loading PICT 130 (banana icons)", true);	SetRect(&tempRect, 768, 384, 992, 438);	DrawPicture(tempPict, &tempRect);	ReleaseResource((Handle)tempPict);	UseResFile(theFileStuff.worldFile);		// hazards		tempPict = GetPicture(133);		if (tempPict == nil) FatalError("Error loading PICT 133 (hazards)", true);	SetGWorld(theGWorlds.hazardGWorld, nil);	DrawPicture(tempPict, &(theGWorlds.hazardGWorld->portRect));	ReleaseResource((Handle)tempPict);		// talisman	tempPict = GetPicture(134);	if (tempPict == nil) FatalError("Error loading PICT 134 (talisman)", true);	SetGWorld(theGWorlds.talismanGWorld, nil);#ifndef DEMO	if (theWorldType == typeTalisman) DrawPicture(tempPict, &(theGWorlds.talismanGWorld->portRect));	else	{		Rect talismanRect;				SetRect(&talismanRect, 0, 0, 44, 66);		DrawPicture(tempPict, &talismanRect);	}#else	DrawPicture(tempPict, &(theGWorlds.talismanGWorld->portRect));#endif		ReleaseResource((Handle)tempPict);			SetGWorld(&theUserInterface.myCWindowRecord.port, GetMainDevice());}void	LoadExtraSounds(void){	short	i, hazardSoundsFound, scriptSounds;	UseResFile(theFileStuff.worldFile);	// load sounds for small hazards from world or data files	hazardSoundsFound = 0;	for (i = 0; i < 8; i++)	{	 	theAudioStuff.theSounds[i + sndSmallHazard1Death - 128] = Get1Resource('snd ', i + sndSmallHazard1Death);		if ((theAudioStuff.theSounds[i + sndSmallHazard1Death - 128] == nil) || (ResError() != noErr))		{			UseResFile(theFileStuff.GWDataFileNumber);	 		theAudioStuff.theSounds[i + sndSmallHazard1Death - 128] = Get1Resource('snd ', i + sndSmallHazard1Death);			if ((theAudioStuff.theSounds[i + sndSmallHazard1Death - 128] == nil) || (ResError() != noErr))					FatalError("Error loading small hazard sounds", true);					UseResFile(theFileStuff.worldFile);		}		else hazardSoundsFound++;		MoveHHi(theAudioStuff.theSounds[i + sndSmallHazard1Death - 128]);		HLock(theAudioStuff.theSounds[i + sndSmallHazard1Death - 128]);	}	// now load the sounds associated with scripts	UseResFile(theFileStuff.worldFile);	scriptSounds = Count1Resources('snd ') - hazardSoundsFound;	if (scriptSounds > 25) scriptSounds = 25;	for (i = 0; i < scriptSounds; i++)	{	 	theAudioStuff.theSounds[i + sndSmallHazard8Death - 128] = Get1Resource('snd ', i + sndSmallHazard8Death + 1);		if (theAudioStuff.theSounds[i + sndSmallHazard8Death - 128])		{			MoveHHi(theAudioStuff.theSounds[i + sndSmallHazard8Death - 128]);			HLock(theAudioStuff.theSounds[i + sndSmallHazard8Death - 128]);		}	}}void	LoadTheMonsters(void){	short 				count, i, j;	MonsterSpritePtr	tempSprite;	// first load the sprite definitions	count = Count1Resources('sDEF');		for (i = 0; i < count; i++)	{		spriteDefinitions[i] = (MonsterDefHandle)Get1Resource('sDEF', 1000 + i);		if ((spriteDefinitions[i] == nil) || (ResError() != noErr))	FatalError("Error loading sprite definition", true);		DetachResource((Handle)spriteDefinitions[i]);	}		// then the sprite scripts		count = Count1Resources('SCRT');		for (i = 0; i < count; i++)	{		spriteScripts[i] = (SCRTHandle)Get1Resource('SCRT', 128 + i);		DetachResource((Handle)spriteScripts[i]);	}		// then the sprites#ifndef DEMO	if (theFileStuff.saveFileInUse)	// load from a saved game file	{		// will have loaded them in LoadGame();	}	else	// load them from the world file	{#endif#ifdef DEMO		count = Count1Resources('room');	// can't be more than the number of rooms#else		count = Count1Resources('rDta');#endif				for (j = 0; j < count; j++)		{			Handle	tempHandle;						// load the monster resource			tempHandle = Get1Resource('mNsT', 128 + j);									if (tempHandle != nil)			{				short count2 = GetResourceSizeOnDisk(tempHandle) / sizeof(SpriteResource);				for (i = 0; i < count2; i++)				{					SpriteResource	tempData;					BlockMoveData(*tempHandle + (i * sizeof(SpriteResource)), &tempData, sizeof(SpriteResource));									tempSprite = AllocateMonster();					tempSprite->kind = maskMonster;					tempSprite->subKind = tempData.subKind;					tempSprite->theRect.left = tempData.theRect.left;					tempSprite->theRect.top = tempData.theRect.top;					tempSprite->theRect.right = tempData.theRect.right;					tempSprite->theRect.bottom = tempData.theRect.bottom;					tempSprite->room = j;					tempSprite->maxSpeed = 3 * tempData.speed;					tempSprite->spriteType = (**spriteDefinitions[tempSprite->subKind]).spriteType;					tempSprite->spriteMovement = (**spriteDefinitions[tempSprite->subKind]).spriteMovement;					tempSprite->layer = (**spriteDefinitions[tempSprite->subKind]).spriteLayer;							tempSprite->aggression = tempData.aggression;					tempSprite->frames = (**spriteDefinitions[tempSprite->subKind]).frames;					tempSprite->hitPoints = tempData.hitPoints;					tempSprite->maxHitPoints = tempSprite->hitPoints;					tempSprite->animationSpeed = (**spriteDefinitions[tempSprite->subKind]).animationSpeed;					tempSprite->animationCounter = tempSprite->animationSpeed;					tempSprite->bananaAction = (**spriteDefinitions[tempSprite->subKind]).bananaAction;					tempSprite->sourceRowBytes = (0x7FFF & (**theGWorlds.monsterPixMap[tempSprite->subKind]).rowBytes);	// only need to do this once									tempSprite->directionCount = 30;					tempSprite->directionMoving = tempData.initiallyFacing & 1; // 2 -> 0					tempSprite->directionFacing = tempSprite->directionMoving;										if (tempSprite->spriteMovement == spriteMovementVertical) tempSprite->directionFacing = directionRight;					tempSprite->frame = 0;				}				ReleaseResource(tempHandle);			}		}#ifndef DEMO	}#endif}void	LoadTheDoors(void){	short			count, i;	DoorSpritePtr	tempSprite;	short			wasResFile = CurResFile();	// first load the door definitions	UseResFile(theFileStuff.GWDataFileNumber);	count = Count1Resources('dDEF');	// should be 8		for (i = 0; i < count; i++)	{		doorDefinitions[i] = (DoorDefHandle)Get1Resource('dDEF', 200 + i);		if ((doorDefinitions[i] == nil) || (ResError() != noErr))	FatalError("Error loading door definition", true);		DetachResource((Handle)doorDefinitions[i]);	}	// then the doors#ifndef DEMO		if (theFileStuff.saveFileInUse != 0)	{		// loaded in LoadGame();	}	else	{#endif		UseResFile(theFileStuff.worldFile);		count = Count1Resources('dOoR');				for (i = 0; i < count; i++)		{			DoorResourceHandle tempDoorResource;						tempDoorResource = (DoorResourceHandle)Get1Resource('dOoR', 1000 + i);			if (tempDoorResource)			{				tempSprite = AllocateDoor();								tempSprite->kind = maskDoor;				tempSprite->subKind = (**tempDoorResource).subKind;										tempSprite->theRect.left = (**tempDoorResource).theRect.left;				tempSprite->theRect.top = (**tempDoorResource).theRect.top;				tempSprite->theRect.right = (**tempDoorResource).theRect.right;				tempSprite->theRect.bottom = (**tempDoorResource).theRect.bottom;								tempSprite->room = (**tempDoorResource).room;				tempSprite->darwinDoor = (**tempDoorResource).darwin;	// 0 = left, 1 = right				tempSprite->doorNumber = (**tempDoorResource).doorNumber;				tempSprite->doorDestination = (**tempDoorResource).doorDestination;				tempSprite->stayOpen = (**tempDoorResource).stayOpen;								tempSprite->frames = (**doorDefinitions[tempSprite->subKind]).frames;				tempSprite->frame = 0;				tempSprite->sourceRowBytes = (0x7FFF & (**theGWorlds.doorPixMap[tempSprite->subKind]).rowBytes);	// only need to do this once								if ((tempSprite->subKind > 1) && (tempSprite->subKind < 6))	// door which can be opened by a key, so a little more work needed				{					tempSprite->hArray = tempSprite->theRect.left/24;					tempSprite->vArray = tempSprite->theRect.top/24;				}				else if (tempSprite->subKind == 7)				{					tempSprite->hArray = tempSprite->theRect.left/24;					tempSprite->vArray = tempSprite->theRect.top/24;				}				else if (tempSprite->subKind == 0)				{					if (tempSprite->doorNumber == 0)					{						tempSprite->frame = 15;	// CHANGED						tempSprite->frameDirection = -1;					}					else if (tempSprite->doorNumber == 1000) tempSprite->kind = maskDoorInactive;				}				ReleaseResource((Handle)tempDoorResource);			}			else FatalError("Error loading door", true);		}#ifndef DEMO	}#endif		UseResFile(wasResFile);}// load the collectablesvoid	LoadTheItems(void){	short	numberOfRooms, i, height, width;#ifdef DEMO	RoomHandle	theRoomHandle;	short **other;#else	short	**tempRoomData;#endif	TalismanSpritePtr	tempTalisman;	#ifndef DEMO	if (theFileStuff.saveFileInUse)	{		// done within LoadGame();	}	else	{#endif#ifdef DEMO		numberOfRooms = Count1Resources('room');#else		numberOfRooms = Count1Resources('rDta');#endif				for (i = 0; i < numberOfRooms; i++)		{			// presume we have already checked the integrity of the world file						// get the dimensions of this room					#ifdef DEMO			theRoomHandle = (RoomHandle)Get1Resource('room', 128 + i);			if ((theRoomHandle == nil) || (ResError() != noErr)) FatalError("Error loading room", true);			width = (**theRoomHandle).width;			height = (**theRoomHandle).height;					ReleaseResource((Handle)theRoomHandle);			other = (short **)Get1Resource('wDta', 130 + (3 * i));			if ((other == nil) || (ResError() != noErr)) FatalError("Error loading items for room", true);								LoadItemsForRoom(width, height, other, i);			ReleaseResource((Handle)other);		#else			tempRoomData = (short **)Get1Resource('rDta', 128 + i);			if ((tempRoomData == nil) || (ResError() != noErr)) FatalError("Error loading room", true);			width = (**(RoomHandle)tempRoomData).width;			height = (**(RoomHandle)tempRoomData).height;					LoadItemsForRoom(width, height, tempRoomData, i);			ReleaseResource((Handle)tempRoomData);		#endif				}#ifndef DEMO	}#endif			StoreKeyCopies();		// fill the talisman bit field		talismanBitField = 0x0FFF;	// assume all talisman parts have been collected		tempTalisman = firstTalisman;		while (tempTalisman != nil)	{		BitClr(&talismanBitField, 15 - tempTalisman->subKind);		tempTalisman = tempTalisman->nextSprite;	}	}void	LoadItemsForRoom(short width, short height, short **other, short room){	short				whatItem, i, j;	ItemSpritePtr		tempItem;	TalismanSpritePtr	tempTalisman;		for (i = 0; i < width; i++)	{		for (j = 0; j < height; j++)		{		#ifdef DEMO			whatItem = (*other)[(width * j) + i];		#else			whatItem =  (*other)[(2 * width * height) + (width * j) + i + 10];		#endif					if ((whatItem & maskTalisman) != 0)			{				// part of the talisman								tempTalisman = AllocateTalisman();				tempTalisman->room = room;				tempTalisman->theRect.left = (24 * i) - 12;				tempTalisman->theRect.top = (24 * j) - 12;				tempTalisman->theRect.right = tempTalisman->theRect.left + 48;				tempTalisman->theRect.bottom = tempTalisman->theRect.top + 48;				tempTalisman->subKind = whatItem & 15;						// between 0 and 15				tempTalisman->iconRow = 912;				tempTalisman->needToDraw = false;				tempTalisman->kind = maskTalisman;				tempTalisman->sourceRowBytes = theGWorlds.itemRowOffSet;	// use the scroll			}			else if ((whatItem & maskItem) != 0)			{				// collectable object				tempItem = AllocateItem();				tempItem->room = room;				tempItem->theRect.left = (24 * i) - 12;				tempItem->theRect.top = (24 * j) - 12;				tempItem->theRect.right = tempItem->theRect.left + 48;				tempItem->theRect.bottom = tempItem->theRect.top + 48;				tempItem->subKind = whatItem & 15;						// between 0 and 15				tempItem->iconRow = tempItem->subKind * 48;				tempItem->needToDraw = false;				tempItem->kind = maskItem;				tempItem->sourceRowBytes = theGWorlds.itemRowOffSet;			}		}	}}