// File "gamma.c" - Source for Altering the Gamma Tables of GDevices//   Last updated 9/24/95, MJS // * ****************************************************************************** *////	This is the Source Code for the Gamma Utils Library file. Use this to build//		new functionality into the library or make an A4-based library. //	See the header file "gamma.h" for much more information. -- MJS//// * ****************************************************************************** *#include <Traps.h>#include <Video.h>#include <Devices.h>#include "globals extern.h"#include "gamma.h"long			gammaUtilsInstalled;GammaTrackerHdl	gammaTables;Boolean			screenHasGamma;// * ****************************************************************************** *// * ****************************************************************************** *pascal Boolean IsOneGammaAvailable(GDHandle theGDevice) {		if (NGetTrapAddress(kGetDeviceListTrapNum, ToolTrap) ==			NGetTrapAddress(_Unimplemented, ToolTrap)) return(FALSE);		if (TestDeviceAttribute(theGDevice, screenDevice) && 			TestDeviceAttribute(theGDevice, noDriver)) return(FALSE);		if ((*theGDevice)->gdType == fixedType) return(FALSE);		return(TRUE);	}// * ****************************************************************************** *// * ****************************************************************************** *pascal OSErr SetupGammaTools(){	short err=0;	GammaTrackerHdl tempHdl;	GammaTblPtr	masterGTable;	screenHasGamma = false;	if (gammaUtilsInstalled == kGammaUtilsSig) return(-1);		gammaTables = 0;	gammaUtilsInstalled = kGammaUtilsSig;		err = GetDevGammaTable(theUserInterface.gameGDevice, &masterGTable);	if (err)  return(err);			tempHdl = (GammaTrackerHdl) NewHandle(sizeof(GammaTracker));	if (tempHdl == 0) return(err = MemError());		(*tempHdl)->size = sizeof(GammaTbl) + masterGTable->gFormulaSize +			(masterGTable->gChanCnt * masterGTable->gDataCnt * masterGTable->gDataWidth / 8);	(*tempHdl)->dataOffset = masterGTable->gFormulaSize;	(*tempHdl)->theGDevice = theUserInterface.gameGDevice;		(*tempHdl)->saved = (GammaTblHandle) NewHandle((*tempHdl)->size);	if ((*tempHdl)->saved == 0) return(err = MemError());	(*tempHdl)->hacked = (GammaTblHandle) NewHandle((*tempHdl)->size);	if ((*tempHdl)->hacked == 0) return(err = MemError());	BlockMove((Ptr) masterGTable, (Ptr) *(*tempHdl)->saved, (*tempHdl)->size);		(*tempHdl)->next = gammaTables;	gammaTables = tempHdl;	screenHasGamma = true;	return(0);	}// * ****************************************************************************** *// * ****************************************************************************** *pascal OSErr DoOneGammaFade(GDHandle /*theGDevice*/, short percent){	short err=0;	register long size, i, theNum;	unsigned char *dataPtr;	if (gammaUtilsInstalled != kGammaUtilsSig) return(-1);	if (!screenHasGamma) return (-1);	BlockMove((Ptr) *(*gammaTables)->saved, (Ptr) *(*gammaTables)->hacked, (*gammaTables)->size);	dataPtr = (unsigned char *) (*(*gammaTables)->hacked)->gFormulaData + (*gammaTables)->dataOffset;	size = (*(*gammaTables)->hacked)->gChanCnt * (*(*gammaTables)->hacked)->gDataCnt;		for(i=0; i < size; i++)	{		theNum = dataPtr[i];		theNum = (theNum * percent) / 100;		dataPtr[i] = theNum;	}		err = SetDevGammaTable((*gammaTables)->theGDevice, (*gammaTables)->hacked);		return(err);	}// * ****************************************************************************** *// * ****************************************************************************** *pascal OSErr DisposeGammaTools() {	if (gammaUtilsInstalled != kGammaUtilsSig) return(-1); 	if ((*gammaTables)->saved)	DisposeHandle((Handle) (*gammaTables)->saved);	if ((*gammaTables)->hacked)	DisposeHandle((Handle) (*gammaTables)->hacked);	if (gammaTables)			DisposeHandle((Handle) gammaTables);			gammaUtilsInstalled = 0;	return(0);	}// * ****************************************************************************** *// * ****************************************************************************** *pascal OSErr GetDevGammaTable(GDHandle theGDevice, GammaTblPtr *theTable) {	short err=0;	CntrlParam  *myCPB; 	((long *) theTable)[0] = 0; 	if (IsOneGammaAvailable(theGDevice) == 0) return(-1);				if ((myCPB = (CntrlParam *) NewPtrClear(sizeof(CntrlParam))) == 0) return(MemError());	myCPB->csCode = cscGetGamma;	myCPB->ioCRefNum = (*theGDevice)->gdRefNum;	((GammaTblPtr **) myCPB->csParam)[0] = theTable;	err = PBStatusSync((ParmBlkPtr) myCPB);	DisposePtr((Ptr) myCPB);	return(err);	}// * ****************************************************************************** *// * ****************************************************************************** *pascal OSErr SetDevGammaTable(GDHandle theGDevice, GammaTblPtr *theTable) {	CntrlParam *myCPB;	short err=0;	CTabHandle cTab;	GDHandle saveGDevice; 	if (IsOneGammaAvailable(theGDevice) == 0) return(-1);	if ((myCPB = (CntrlParam *) NewPtrClear(sizeof(CntrlParam))) == 0) return(MemError());	myCPB->csCode = cscSetGamma;	myCPB->ioCRefNum = (*theGDevice)->gdRefNum;	((GammaTblPtr **) myCPB->csParam)[0] = theTable;	err = PBControlSync((ParmBlkPtr) myCPB); 	if (err == 0) {		saveGDevice = GetGDevice();		SetGDevice(theGDevice); 		cTab = (*(*theGDevice)->gdPMap)->pmTable;		SetEntries (0, (*cTab)->ctSize, (*cTab)->ctTable);		SetGDevice(saveGDevice);		}	DisposePtr((Ptr) myCPB);	return (err);	}