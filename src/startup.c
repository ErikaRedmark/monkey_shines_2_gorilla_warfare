#include	"globals extern.h"#include	"gamma.h"#include	<ControlStrip.h>#include	<MixedMode.h>#include	<OSUtils.h>#include	<Traps.h>#if GENERATINGCFM/*  *//*  If we're not generating CFM, then assume the *//*  68K inlines in the headers apply instead. *//*  *//*  SBIsControlStripVisible is a Pascal routine, *//*  dispatched from the selector in D0, returning *//*  a Boolean result */pascal Boolean SBIsControlStripVisible ( void ){    enum        {        uppSBIsControlStripVisibleInfo = kD0DispatchedPascalStackBased            | RESULT_SIZE (SIZE_CODE (sizeof(Boolean)))            | DISPATCHED_STACK_ROUTINE_SELECTOR_SIZE (kFourByteCode)            };            return CallUniversalProc (            GetToolTrapAddress (_ControlStripDispatch),            uppSBIsControlStripVisibleInfo, 0x00);}pascal void SBShowHideControlStrip(Boolean showIt){    enum        {        uppSBShowHideControlStripInfo =            kD0DispatchedPascalStackBased            | DISPATCHED_STACK_ROUTINE_SELECTOR_SIZE (kFourByteCode)            | DISPATCHED_STACK_ROUTINE_PARAMETER                (1, SIZE_CODE (sizeof (showIt)))            };            CallUniversalProc (            GetToolTrapAddress (_ControlStripDispatch),            uppSBShowHideControlStripInfo, 0x01, showIt);}#else   /*  not GENERATINGCFM */#include <ControlStrip.h>#endif /*  GENERATINGCFM */void	InitialiseToolBox( void ){	/* Toolbox initialisations  */	InitGraf( &qd.thePort);	InitFonts();	InitWindows();	InitMenus();	TEInit();	InitDialogs(nil);	InitCursor();	GetDateTime((unsigned long *)&qd.randSeed);	MoreMasters(); MoreMasters(); MoreMasters(); MoreMasters(); MoreMasters();	MoreMasters(); MoreMasters(); MoreMasters(); MoreMasters(); MoreMasters();	MaxApplZone();#ifdef DEMO	hackedOne = false;	hackedTwo = false;	hackedThree = false;	hackedFour = false;	hackedFive = false;	hackedSix = false;	hackedSeven = false;#endif}void	StartupStuff( void ){	OSErr			theError;	FCBPBRec		theFileRec;	NumVersion		nVers;	Rect			tempRect;	Str255			fileName;	FSSpec			GWDataFile;	PicHandle		tempPict;		// Initialise the Macintosh toolbox		InitialiseToolBox();		theAudioStuff.madLibraryLoaded = false;	theAudioStuff.musicPlaying = noMusic;	theUserInterface.cursorHidden = false;	#ifndef DEMO		theError = AEInstallEventHandler(kCoreEventClass, kAEOpenDocuments, NewAEEventHandlerProc(HandleOpenDocAE), 0, false);	#endif		nVers = SndSoundManagerVersion();	if( nVers.majorRev < 3) FatalError("Gorilla Warfare requires Sound Manager 3.0 or higher.", false);	//¥	Make sure that the Sprocket libraries are present	if (ISpInit == nil) FatalError("Gorilla Warfare requires InputSprocket.", false);			// save the application file and get the parent directory and volume reference numbers	theFileStuff.applicationFile = CurResFile();	#ifdef DEMO	fileCount = 21988872;#endif	theFileRec.ioNamePtr = fileName;	theFileRec.ioRefNum = theFileStuff.applicationFile;	theFileRec.ioVRefNum = 0;	theFileRec.ioFCBIndx = 0;		theError = PBGetFCBInfoSync(&theFileRec);		theFileStuff.GWvolRef = theFileRec.ioFCBVRefNum;	theFileStuff.GWParentDirID = theFileRec.ioFCBParID;	// sound volume needed for preferences	GetDefaultOutputVolume(&theAudioStuff.systemSoundVolume);	// set the sound volume to maximum	SetDefaultOutputVolume(0x01000100);	// preferences needed for screen selection	LoadPreferences();	theUserInterface.gameGDevice = SelectMonitor();	if (theUserInterface.gameGDevice == 0)	FatalError("Can't find a suitable screen.", false);	// check that we have the required data file	#ifdef DEMO		theError = FSMakeFSSpec(theFileStuff.GWvolRef, theFileStuff.GWParentDirID, "\pGorilla Warfare Demo Data", &GWDataFile);		if (theError != noErr)		// search all volumes		{			theError = FindFile(theFileStuff.GWParentDirID, "\pGorilla Warfare Demo Data", &GWDataFile);		}		if (theError != noErr) FatalError("Gorilla Warfare Demo Data not found", false);	#else		theError = FSMakeFSSpec(theFileStuff.GWvolRef, theFileStuff.GWParentDirID, "\pGorilla Warfare Data", &GWDataFile);		if (theError != noErr)		// search all volumes		{			theError = FindFile(theFileStuff.GWParentDirID, "\pGorilla Warfare Data", &GWDataFile);		}		if (theError != noErr) FatalError("Gorilla Warfare Data not found", false);	#endif	theFileStuff.GWDataFileNumber = FSpOpenResFile(&GWDataFile, fsCurPerm);	// gamma fade to hide resolution switching	SetupGammaTools();	DoOneGammaFade(theUserInterface.gameGDevice, 0);#ifdef DEMO	fileDate = 3063903761;#endif	// do some stuff for the serial number#ifndef DEMO	serialNumberHandle = (SerialNumHnd)NewHandleClear(sizeof(SerialNumRec));	(**serialNumberHandle).serialNumber = 22423;#endif	// open the data file	UseResFile(theFileStuff.applicationFile);	SetupGWorlds();	// largest memory allocation, so right at the start and lock them high	UseResFile(theFileStuff.applicationFile);		theUserInterface.controlStripAvailable = IsControlStripAvailable();		if (theUserInterface.controlStripAvailable)	{		theUserInterface.controlStripUsed = SBIsControlStripVisible();		if (theUserInterface.controlStripUsed)	SBShowHideControlStrip(false);	}#ifndef DEMO	(**serialNumberHandle).serialNumber *= 1152;#endif	// one way or another we should have a graphics device we can use		if (ChangeResolution() == false)	{		DoOneGammaFade(theUserInterface.gameGDevice, 100);		DisposeGammaTools();		FatalError("Resolution Switch Failed", false);	}	theUserInterface.myCursor = GetCCursor(128);	SetCCursor(theUserInterface.myCursor);#ifndef DEMO	(**serialNumberHandle).serialNumber += 467;#endif	StartupHideMenuBar();	HideTheMenuBar();		SetupWindow();	ForeColor(blackColor);	PaintRect(&theUserInterface.myCWindowRecord.port.portRect);#ifdef DEMO	fileLength = 3044960;#endif		SetRect(&tempRect, 0, 0, 640, 480);	SetGWorld(theGWorlds.screenGWorld, nil);	UseResFile(theFileStuff.GWDataFileNumber);	tempPict = GetPicture(999);	DrawPicture(tempPict, &tempRect);	if (tempPict == nil) FatalError("Error loading PICT 999", true);	ReleaseResource((Handle)tempPict);	SetGWorld(&theUserInterface.myCWindowRecord.port, GetMainDevice());	UseResFile(theFileStuff.applicationFile);	DoOneGammaFade(theUserInterface.gameGDevice, 100);	FlashFadeIn();	DisposeGammaTools();	// prepare joystick handling	InitialiseInputSprocket();#ifdef DEMO	WorldCheckOne();#else	HackCheck();#endif	CustomHideCursor();	InitSoundChannels();	SetSoundVolume((**gPrefs).soundVolume);	StartInterfaceMusic();}/*****************************************************************************/// check for hacking, etc.#ifndef	DEMOvoid	HackCheck( void ){	short		tempResFile;	OSErr		theError;	long		**tempCode;	VCB			*theVCB;	Boolean		fileFound;	long		numFound;	FSSpec		fileSpec;	Boolean		hacked;		hacked = false;	tempResFile = CurResFile();	UseResFile(theFileStuff.applicationFile);		// check for the hack programs by creator and type		// for all volumes mounted need to call CreatorTypeFileSearch	// until a file is found		fileFound = false;	theVCB = (VCB *)(GetVCBQHdr()->qHead);	while ( (theVCB != NULL) && !fileFound )	{		/* Check VCB signature before using VCB. Don't have to check for */		/* MFS (0xd2d7) because they can't get big enough to be pinned */		if (( theVCB->vcbSigWord == 0x4244 ) || (theVCB->vcbSigWord == 0x482B))		{			// it's a real volume, so search it			theError = CreatorTypeFileSearch(nil, theVCB->vcbVRefNum, 'SESU', 'APPL', &fileSpec, 1,														&numFound, true);						if ((theError == noErr) && (numFound != 0)) fileFound = true;			theError = CreatorTypeFileSearch(nil, theVCB->vcbVRefNum, 'KRAK', 'APPL', &fileSpec, 1,														&numFound, true);						if ((theError == noErr) && (numFound != 0)) fileFound = true;			theError = CreatorTypeFileSearch(nil, theVCB->vcbVRefNum, 'RgAP', 'APPL', &fileSpec, 1,														&numFound, true);						if ((theError == noErr) && (numFound != 0)) fileFound = true;		}				if ( !fileFound ) theVCB = (VCB *)(theVCB->qLink);	}		if (fileFound)	hacked = true;				// now check if the registration data in the application is same as in the prefs		// if there is a prefs resource in the application, then the game has been		// registered at some point		tempCode = (long **)Get1Resource('CODE', 1);		CheckRegistration();		if (gRegistered)		{			Boolean	cheated = false;			if (tempCode)			{				// the prefs file is a registered one.				// check tempPrefs to make sure it is not fiddled. If it is, unregister it								if ((*tempCode)[318] != 99874) cheated = true;				if ((*tempCode)[143] != (**gPrefs).registrationCode) cheated = true;			}			else cheated = true;			if (cheated)			{				// looks like the registration data from the file isn't the same as in the				// application								(**gPrefs).registrationCode = 0;				CopyString((**gPrefs).registerName, "\pUnregistered");				UpdatePreferences();			}		}		if (tempCode) ReleaseResource((Handle)tempCode);			if (hacked)		{			// some sort of hack is present						// now want to check the version number, and if it is the first time with a new version,			// unregister it whatever.						cracksInstalled = true;						if ((**gPrefs).serialNumber == 65)			{				// simply version 1.0.3. C & N was not installed last time, so unregister it								CopyString((**gPrefs).registerName, "\pYour name");				(**gPrefs).registrationCode = 0;				gRegistered = 0;								// then update the version number in the prefs								(**gPrefs).serialNumber = 66;				// write out the modified preferences to disk											UpdatePreferences();			}			else if ((**gPrefs).serialNumber == 66)			{				// version 1.0.3 but C&N was already installed - presumably unregistered it before				// so don't bother this time			}			else			{				// unregister it								CopyString((**gPrefs).registerName, "\pYour name");				(**gPrefs).registrationCode = 0;				gRegistered = 0;								// then update the version number in the prefs								(**gPrefs).serialNumber = 65;				UpdatePreferences();	// write out the modified preferences to disk			}		}		else	// no hacking		{			cracksInstalled = false;						if ((**gPrefs).serialNumber == 66)			{				// it was hacked last time, so reset the counter so it can be unregistered next time.								(**gPrefs).serialNumber = 65;				UpdatePreferences();	// write out the modified preferences to disk			}		}	UseResFile(tempResFile);}#endifstatic Boolean IsControlStripAvailable (void){	OSStatus	err;	long		response;		err = Gestalt (gestaltControlStripAttr, &response);	if	(		response & (1 << gestaltControlStripExists)) {		// It is safe to call Control Strip		return true;	}	else	{		// It is not safe to call Control Strip		return false;	}}