#include	"globals extern.h"#include	"gamma.h"extern	FilePlayCompletionUPP	soundCallback;/****************************************************************************//*																			*//*			Main level handling routine										*//*																			*//****************************************************************************/#ifdef useProfiler#pragma profile on#endifshort		RunALife(Boolean	teleportSound){	SndCommand theCommand;	UnsignedWide	timeStamp;	short			whatHappened;	Boolean			done;	UnsignedWide	tempTimer, elapsedTime;	unsigned long	framesToRun;	Boolean			frameActuallyRun = false;		SetGWorld(&theUserInterface.myCWindowRecord.port, GetMainDevice());	player.enteredDoor = -1;	// reset door	RunAFrame();	DoBlitting();	DrawLifeBar(); DrawStaminaBar(); DrawScore(); DrawKeyBananaStatus(); DrawLivesLeft(); DrawTheMap();		/* Run until something happens to exit level */	done = false;	whatHappened = 0;		// TODO - just install a time manager task to count the number of frames	Microseconds(&timeStamp); // make sure a frame gets run immediately		if (timeStamp.lo > 17000) timeStamp.lo -= 17000;	else	{		timeStamp.hi--;		timeStamp.lo += 4294950295;	// wrap around	}		if (teleportSound) PlayASound(sndExitTimeMachine);		do	{		// need to work out how many frames to run				Microseconds(&tempTimer);		if (tempTimer.hi == timeStamp.hi)		{			elapsedTime.lo = tempTimer.lo - timeStamp.lo;		}		else		{			// should flick over every 70 mins or so						elapsedTime.lo = tempTimer.lo + 4294967295 - timeStamp.lo;		}		framesToRun = (elapsedTime.lo)/33333;	// 33333 = 30 fps				if (justSaved)		{			framesToRun = 1;			justSaved = false;	// stop the game trying to catch up when you save a game		}				if (framesToRun > 0)		{			do {					RunAFrame();				} while (--framesToRun);			frameActuallyRun = true;			timeStamp.lo = tempTimer.lo;	// remember when the last frame was run			timeStamp.hi = tempTimer.hi;		}		else	frameActuallyRun = false;		#ifndef DEMO		if ((theAudioStuff.musicType == typeAIFF) && (theAudioStuff.restartMusic))		{			SndStartFilePlay (theAudioStuff.musicChannel, theAudioStuff.fileRefNum, nil, 20480, nil, nil, soundCallback, true);			theAudioStuff.restartMusic = false;		}	#endif				// now blit the sprites to the safe GWorld		if ((!player.gDead) && frameActuallyRun)	DoBlitting();					// if player has not died, check if moved off screen		if (player.gDead)		{			done = true;			whatHappened = 999;		}						#ifndef DEMO			// check world completed						if (theWorldType == typeTalisman)			{									}			else			{				// have to kill all the monsters, so check if this has been done								short				count;				MonsterSpritePtr	tempMonster = firstMonster;							count = 0;								do				{					if (tempMonster->subKind == theUniqueMonsterNumber) count++;					tempMonster = tempMonster->nextSprite;				}				while (tempMonster != nil);							if (count == 0)				{					done = true;					whatHappened = 32767;				}			}		#else			if (firstTalisman == 0)			{				done = true;				whatHappened = 1001;			}		#endif				if (player.enteredDoor > -1)		{			done = true;			whatHappened = player.enteredDoor;		}	} while(!done);	theCommand.cmd = quietCmd;	theCommand.param1 = 0;	theCommand.param2 = 0;		SndDoImmediate(theAudioStuff.beanieChannel, &theCommand);	theCommand.cmd = flushCmd;	theCommand.param1 = 0;	theCommand.param2 = 0;	SndDoImmediate(theAudioStuff.beanieChannel, &theCommand);	theCommand.cmd = quietCmd;	theCommand.param1 = 0;	theCommand.param2 = 0;		SndDoImmediate(theAudioStuff.jetPackChannel, &theCommand);	theCommand.cmd = flushCmd;	theCommand.param1 = 0;	theCommand.param2 = 0;	SndDoImmediate(theAudioStuff.jetPackChannel, &theCommand);	saveMessageCounter = 0;	saveMessageTwoCounter = 0;	return whatHappened;}void	RunAFrame(void){	ItemSpritePtr			tempItem;	BananaSpritePtr			tempBanana;	TalismanSpritePtr		tempTalisman;	GWParticleWrapperPtr	tempParticle;	Rect					drawingRect;	HandlePlayer();		// clean up after player handling	player.theRect.right = player.theRect.left + darwinWidth;	player.theRect.bottom = player.theRect.top + darwinHeight;		// for collision		player.source = (short *)(theGWorlds.darwinMemPtr + (theGWorlds.darwinRowOffSet * player.iconRow) + (2 * darwinWidth * player.frame));	// handle scrolling inertia		// TODO - more work needed to keep it smooth	// TODO - remove scrolling inertia for horizontal and reset values after dying.	if (scrollOffsetH > 150)	scrollOffsetH = 150;	else if (scrollOffsetH > 75) scrollOffsetH -= 2;	else if ((scrollOffsetH > 1) && (player.speedh == 0)) scrollOffsetH -= 1;	else if (scrollOffsetH < -150) scrollOffsetH = -150;	else if (scrollOffsetH < -75) scrollOffsetH += 2;	else if ((scrollOffsetH < -1) && (player.speedh == 0)) scrollOffsetH += 1;	else if ((scrollOffsetH >= -1) && (scrollOffsetH <= 1)) scrollOffsetH = 0;		if (scrollOffsetV > 100)	scrollOffsetV = 100;	else if (scrollOffsetV > 75) scrollOffsetV -= 4;	else if ((scrollOffsetV > 1) && (player.speedv == 0)) scrollOffsetV -= 1;	else if (scrollOffsetV < -100) scrollOffsetV = -100;	else if (scrollOffsetV < -75) scrollOffsetV += 3;	else if ((scrollOffsetV < -1) && (player.speedv == 0)) scrollOffsetV += 1;	else if ((scrollOffsetV >= -1) && (scrollOffsetV <= 1)) scrollOffsetV = 0;		// now need to make sure we don't scroll past the edge of the world			// this is done within PreCalculateVisibleRect();		// now we know where Darwin will be, so work out which Rects of each screen	// need to be drawn so that we can decide which sprites need drawing.	PreCalculateVisibleRect(&drawingRect);	// if Darwin has moved far enough, dispose of current rows/columns and load new		LoadDisposeRowColumn();	// handle the sprites	HandleMonsters(&drawingRect);	HandleDoors(&drawingRect);	HandleTalisman(&drawingRect);	HandleItems(&drawingRect);	HandleBananas(&drawingRect);	HandleSprings(&drawingRect);	HandleHazards();	HandleDissolvers();	HandleConveyors();		// now handle the particles		tempParticle = firstParticle;		while (tempParticle)	{		short i;		Boolean	dispose;				for (i = 0; i < tempParticle->numberOfParticles; i++)		{			dispose = HandleParticle(&tempParticle->particleList[i], &drawingRect);			if (dispose) tempParticle->numberOfActiveParticles--;		}		tempParticle = tempParticle->nextParticle;	}	// do any sprites need disposing ?	tempItem = firstItem;		while (tempItem)	{		if (tempItem->kind == kSpriteDone) tempItem = DisposeItem(tempItem);		else tempItem = tempItem->nextSprite;	}		tempTalisman = firstTalisman;		while (tempTalisman)	{		if (tempTalisman->kind == kSpriteDone) tempTalisman = DisposeTalisman(tempTalisman);		else tempTalisman = tempTalisman->nextSprite;	}	tempBanana = firstBanana;		while (tempBanana)	{		if (tempBanana->kind == kSpriteDone) tempBanana = DisposeBanana(tempBanana);		else tempBanana = tempBanana->nextSprite;	}	// do any particles need disposing ?		tempParticle = firstParticle;	while (tempParticle)	{		if (tempParticle->numberOfActiveParticles == 0)	tempParticle = DisposeParticle(tempParticle);		else tempParticle = tempParticle->nextParticle;	}	// now deal with collisions	HandleCollisions();	// check for power-ups expiring	if (player.powerUp & (doublePoints + quadPoints + beanieHat + fastFire + powerFire + multipleFire + shield + jetPack))	{		// have a power-up which is controlled by a timer				if (player.powerUp & (doublePoints + quadPoints))		{			if ((frameCount & 2) == 2) player.multiplierTimer--;						if (player.multiplierTimer == 0)			{				player.powerUp = player.powerUp & (fastFire + beanieHat + powerFire + multipleFire + shield + jetPack);				player.gPointsMultiplier = 1;			}		}				if (player.powerUp & fastFire)		{			if ((frameCount & 2) == 2) player.fastFireTimer--;						if (player.fastFireTimer == 0)			{				player.powerUp = player.powerUp & (doublePoints + quadPoints + beanieHat + powerFire + multipleFire + shield + jetPack);			}		}		if (player.powerUp & powerFire)		{			if ((frameCount & 2) == 2) player.powerFireTimer--;						if (player.powerFireTimer == 0)			{				player.powerUp = player.powerUp & (doublePoints + quadPoints + beanieHat + fastFire + multipleFire + shield + jetPack);			}		}		if (player.powerUp & multipleFire)		{			if ((frameCount & 2) == 2) player.multipleFireTimer--;						if (player.multipleFireTimer == 0)			{				player.powerUp = player.powerUp & (doublePoints + quadPoints + beanieHat + powerFire + fastFire + shield + jetPack);			}		}				if (player.powerUp & shield)		{			if ((frameCount & 2) == 2) player.shieldTimer--;						if (player.shieldTimer == 0)			{				player.powerUp = player.powerUp & (doublePoints + quadPoints + beanieHat + fastFire + powerFire + multipleFire + jetPack);				PlayASound(sndShieldExpire);			}			else if (player.shieldTimer == 15) PlayASound(sndAlarm);			else if (player.shieldTimer == 30) PlayASound(sndAlarm);			else if (player.shieldTimer == 45) PlayASound(sndAlarm);		}		if (player.powerUp & beanieHat)		{			if ((frameCount & 2) == 2) player.beanieTimer--;						if (player.beanieTimer == 0)			{				// reset the flags and stop the sounds								SndCommand	theCommand;							player.powerUp = player.powerUp & (doublePoints + quadPoints + shield + fastFire + powerFire + multipleFire + jetPack);								PlayASound(sndBeanieExpire);								theCommand.cmd = quietCmd;				theCommand.param1 = 0;				theCommand.param2 = 0;								SndDoImmediate(theAudioStuff.beanieChannel, &theCommand);						theCommand.cmd = flushCmd;				theCommand.param1 = 0;				theCommand.param2 = 0;							SndDoImmediate(theAudioStuff.beanieChannel, &theCommand);			}			else			{				SCStatus	theStatus;				SndChannelStatus(theAudioStuff.beanieChannel, sizeof(SCStatus), &theStatus);				if (theStatus.scChannelBusy == false) BeanieSound();								if (player.beanieTimer == 15) PlayASound(sndAlarm);				else if (player.beanieTimer == 30) PlayASound(sndAlarm);				else if (player.beanieTimer == 45) PlayASound(sndAlarm);			}		}			if (player.powerUp & jetPack)		{			if ((frameCount & 2) == 2) player.jetPackTimer--;						if (player.jetPackTimer == 0)			{				SndCommand	theCommand;				player.powerUp = player.powerUp & (doublePoints + quadPoints + beanieHat + fastFire + powerFire + multipleFire + shield);				PlayASound(sndJetPackExpire);				SetupDarwinFalling();				theCommand.cmd = quietCmd;				theCommand.param1 = 0;				theCommand.param2 = 0;								SndDoImmediate(theAudioStuff.jetPackChannel, &theCommand);						theCommand.cmd = flushCmd;				theCommand.param1 = 0;				theCommand.param2 = 0;							SndDoImmediate(theAudioStuff.jetPackChannel, &theCommand);			}			else			{				SCStatus	theStatus;				SndChannelStatus(theAudioStuff.jetPackChannel, sizeof(SCStatus), &theStatus);				if (theStatus.scChannelBusy == false) JetPackSound();								if (player.jetPackTimer == 15) PlayASound(sndAlarm);				else if (player.jetPackTimer == 30) PlayASound(sndAlarm);				else if (player.jetPackTimer == 45) PlayASound(sndAlarm);			}		}					DrawKeyBananaStatus();	}	// if this frame is numbered even, make the next one odd and vice versa	frameCount = (++frameCount) % 8;	if (player.delayToNextThrow > 0) player.delayToNextThrow--;	// coutdown to when Darwin can next throw a banana}/****************************************************************************//*																			*//*			Copy everything to the screen									*//*																			*//****************************************************************************/void DoBlitting(){	short					horiz, vert;	SpringSpritePtr			tempSpring;	HazardSpritePtr			tempHazard;	ConveyorSpritePtr		tempConveyor;	DissolverSpritePtr		tempDissolver;	BananaSpritePtr			tempBanana;	MonsterSpritePtr		tempMonster;	DoorSpritePtr			tempDoor;	ItemSpritePtr			tempItem;	TalismanSpritePtr		tempTalisman;	GWParticleWrapperPtr	tempParticle;	Rect					srcRect, dstRect;	Rect					drawingRect;	PreCalculateVisibleRect(&drawingRect);		// for parallax, draw the whole screen	DrawThePlatforms();	// work out where Darwin is in GWorld coordinates		horiz = player.theRect.left - (24 * minActualHoriz);	vert = player.theRect.top - (24 * minActualVert);		// draw the sprites		tempSpring = firstSpring;		while (tempSpring)	{		if (tempSpring->needToDraw)		{			if (tempSpring->artificiallySprung) tempSpring->artificiallySprung = false;	// keep springs synchronised			SpringBlit(tempSpring->source, theGWorlds.platformRowOffSet,				tempSpring->dest, tempSpring->drawingHeight);		}		tempSpring = tempSpring->nextSprite;	}	tempHazard = firstHazard;		while (tempHazard)	{		if (tempHazard->needToDraw)		{			SmallBlit(tempHazard->source, tempHazard->sourceRowBytes, tempHazard->dest);		}		tempHazard = tempHazard->nextSprite;	}	tempConveyor = firstConveyor;		while (tempConveyor)	{		if (tempConveyor->needToDraw)		{			SmallBlit(tempConveyor->source, theGWorlds.platformRowOffSet, tempConveyor->dest);		}		tempConveyor = tempConveyor->nextSprite;	}	tempItem = firstItem;		while (tempItem)	{		if (tempItem->needToDraw)		{			ItemBlit(tempItem->source, tempItem->sourceRowBytes, tempItem->dest, tempItem->drawingHeight, tempItem->drawingWidth);		}		tempItem = tempItem->nextSprite;	}	tempTalisman = firstTalisman;		while (tempTalisman)	{		if (tempTalisman->needToDraw)		{			ItemBlit(tempTalisman->source, tempTalisman->sourceRowBytes, tempTalisman->dest, tempTalisman->drawingHeight, tempTalisman->drawingWidth);		}		tempTalisman = tempTalisman->nextSprite;	}	tempBanana = firstBanana;		while (tempBanana)	{		if (tempBanana->needToDraw)		{			SmallBlit(tempBanana->source, tempBanana->sourceRowBytes, tempBanana->dest);		}		tempBanana = tempBanana->nextSprite;	}	tempDissolver = firstDissolver;		while (tempDissolver)	{		if (tempDissolver->needToDraw)		{			SmallBlit(tempDissolver->source, theGWorlds.platformRowOffSet, tempDissolver->dest);		}		tempDissolver = tempDissolver->nextSprite;	}	// monsters behind Darwin		tempMonster = firstMonster;		while (tempMonster)	{		if ((tempMonster->needToDraw) && (tempMonster->layer == 0))		{			MonsterBlit(tempMonster->source, tempMonster->sourceRowBytes, tempMonster->dest, tempMonster->drawingHeight,								tempMonster->drawingWidth, tempMonster->directionFacing, tempMonster->inset);		}		tempMonster = tempMonster->nextSprite;	}		tempDoor = firstDoor;		while (tempDoor)	{		if (tempDoor->needToDraw) DoorBlit(tempDoor->source, tempDoor->sourceRowBytes,			tempDoor->dest, tempDoor->drawingHeight, tempDoor->drawingWidth);		tempDoor = tempDoor->nextSprite;	}	BlitDarwin(horiz, vert);		// monsters in front of Darwin	tempMonster = firstMonster;		while (tempMonster)	{		if ((tempMonster->needToDraw) && (tempMonster->layer == 1))		{			MonsterBlit(tempMonster->source, tempMonster->sourceRowBytes, tempMonster->dest, tempMonster->drawingHeight,								tempMonster->drawingWidth, tempMonster->directionFacing, tempMonster->inset);		}		tempMonster = tempMonster->nextSprite;	}	// particles on top of everything else ?		tempParticle = firstParticle;		while (tempParticle)	{		short i;				for (i = 0; i < tempParticle->numberOfParticles; i++)		{					if (tempParticle->particleList[i].needToDraw)	*tempParticle->particleList[i].dest = tempParticle->particleList[i].color;		}		tempParticle = tempParticle->nextParticle;	}		// "can't save" message ?#ifdef DEMO	if (saveMessageTwoCounter)	{		RGBColor	theColor;				theColor.red = 49000;		theColor.green = 49000;		theColor.blue = 49000;		OpColor(&theColor);		SetRect(&srcRect, 0, 0, 268, 144);		SetRect(&dstRect, horiz - (228 + scrollOffsetH) + 154, vert - (120 + scrollOffsetV) + 108,							horiz - (228 + scrollOffsetH) + 422, vert - (120 + scrollOffsetV) + 252);				CopyBits( &((GrafPtr)theGWorlds.saveMessageTwoGWorld)->portBits, &((GrafPtr)theGWorlds.safeGWorld)->portBits,			&srcRect, &dstRect, srcCopy + blend, ( RgnHandle )0L );				saveMessageTwoCounter--;		}	else#endif	if (saveMessageCounter)	{		RGBColor	theColor;				theColor.red = 49000;		theColor.green = 49000;		theColor.blue = 49000;		OpColor(&theColor);		SetRect(&srcRect, 0, 0, 268, 144);		SetRect(&dstRect, horiz - (228 + scrollOffsetH) + 154, vert - (120 + scrollOffsetV) + 108,							horiz - (228 + scrollOffsetH) + 422, vert - (120 + scrollOffsetV) + 252);				CopyBits( &((GrafPtr)theGWorlds.saveMessageGWorld)->portBits, &((GrafPtr)theGWorlds.safeGWorld)->portBits,			&srcRect, &dstRect, srcCopy + blend, ( RgnHandle )0L );				saveMessageCounter--;	}		// now copy everything to the screen	SetRect(&srcRect,	horiz - (228 + scrollOffsetH), vert - (120 + scrollOffsetV),						horiz + 348 - scrollOffsetH, vert + 240 - scrollOffsetV);//	SetRect(&srcRect,	horiz + 24 - (252 + scrollOffsetH), vert + 24 - (144 + scrollOffsetV),//						horiz + 24 + 324 - scrollOffsetH, vert + 24 + 216 - scrollOffsetV);// (hand optimisation of ...//	SetRect(&srcRect,	horiz + largestSpriteSize - (((screenWidthPixels/2) - (darwinWidth/2)) + scrollOffsetH),//						vert + largestSpriteSize - (((screenHeightPixels/2) - (darwinWidth/2)) + scrollOffsetV),//						horiz + largestSpriteSize + ((screenWidthPixels/2) + (darwinWidth/2)) - scrollOffsetH,//						vert + largestSpriteSize + ((screenHeightPixels/2) + (darwinWidth/2)) - scrollOffsetV);	SetRect(&dstRect, widthInset, heightInset, widthInset + 576, heightInset + 360);		CopyBits( &((GrafPtr)theGWorlds.safeGWorld)->portBits, &((GrafPtr)(&theUserInterface.myCWindowRecord.port))->portBits,  		&srcRect, &dstRect, srcCopy, ( RgnHandle )0L );}#ifdef useProfiler#pragma profile off#endif